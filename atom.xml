<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Freezing</title>
  <icon>http://yoursite.com/icon.png</icon>
  <subtitle>Freezing</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-26T09:32:50.721Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>you06</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「罗素悖论」、自然语言和 void*</title>
    <link href="http://yoursite.com/2021/01/24/russell-paradox-nl-void-any/"/>
    <id>http://yoursite.com/2021/01/24/russell-paradox-nl-void-any/</id>
    <published>2021-01-24T18:26:08.000Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「罗素悖论」在很多地方都有提到，还有个比较通俗易懂的说法是「理发师悖论」，即：</p><center>小城里的理发师放出豪言：他要为城里人刮胡子，而且一定只要为城里所有“不为自己刮胡子的人”刮胡子。<br>但问题是：理发师该为自己刮胡子吗？</center><p>很多文章把这个悖论摆到读者面前的同时，自身却仿佛视悖论为公理的退缩了。「罗素悖论」对集合论带来了一波冲击，指出了其缺陷。数学家们的严谨使得这一悖论所指出的问题被「<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E7%B4%A0%E5%85%AC%E7%90%86%E4%BD%93%E7%B3%BB#%E7%B1%BB%E7%9A%84%E5%86%85%E6%B6%B5%E5%85%AC%E7%90%86">类的内涵公理</a>」所避免；而维特根斯坦则在「逻辑哲学论」中指出「罗素悖论」在讨论不能说的东西，应当避免这种无意义的讨论。</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>根据维的观点，我们的语言是有界限的，当我们超出认知去谈论的一个东西的时候，这就是胡话（nonsense）。例如我命名不可知的一种外星生物叫「八爪鱼」，随之对它的任何描述都没有意义。回到「罗素悖论」并把条件稍加修改，我们假设存在一个「所有我的语言所不能描述的所形成的集合」，那么这个集合本身是否存在于它自身呢？相比于「八爪鱼」这里更加抽象一些，「所有我的语言所不能描述的所形成的集合」，是一个不可被讨论的东西，下了定义并不足以说明这是件被语言所说清楚、可以描述的事情，因为：</p><ul><li><ol><li>世界是一切发生的事情。</li></ol></li><li>5.6 我的语言的界限 意味我的世界的界限。</li></ul><p>所以我们能讨论的集合仅是「所有我的语言能描述的所形成的集合」，而非其互斥集。</p><p>自然语言是不严谨的，我们要时刻小心使用中出现的逻辑漏洞，并严谨的用它作为讨论的工具，让我们进入到愉快的程序语言。</p><p>void* 是什么？</p><p>void* 可以是任何东西！他是「所有我所知道的类型所形成的集合」+「所有我所不知道的类型所形成的集合」，我们令 P 是「所有我所知道的类型所形成的集合」，Q 是「所有我所不知道的类型所形成的集合」。那么 P 里面所有的事情，我都能说的清清楚楚；而 Q 里面所发生的任意一件事，对我们而言都是不明真相的二进制编码。</p><h2 id="自成性"><a href="#自成性" class="headerlink" title="自成性"></a>自成性</h2><p>自举已然是编程语言的常见行为，一门图灵完备的编程语言当然可以实现它自身。在一个对编译器不了解的人读到这句话时，很可能想到的和编译器/解释器所做的大相庭径。我也算不得什么编译器专家，所以结合「逻辑哲学论」的观点，在这里谈一下我对于自举这件事情的看法。</p><p>维特根斯坦在「逻辑哲学论」想要表达的重要观点之一就是把他所写的这本书以及其立场也至于一个被自身否定的地位。这本书是用自然语言撰写的，那么我们不禁想问：如何保证你所使用的自然语言中所用到的对象是你所了解、清楚的呢？如果我们遵守“对于不可说的东西我们必须保持沉默(7)”这一原则，是否会陷入一个没有东西可以说的状态呢？因此维把自己的逻辑也立于这样一个地位，如果你尝试用不可说（nonsense）来否定这本书，那么其否定的立场本身所基于的一定是某些“我们所知道、可以说的”真理。维想要的到的效果是，这一假定的真理本身就是给了这本书一个基石，即当这是“可以说”的时候，论调是成立的，这是“不可说”的时候，对其的否定也处于“不可说”的地位。我们只需要谨慎的，不在“不可说”的领域去应用这一套理论，就不会犯错误。</p><p>回到编程语言中，我们需要谨慎的，不在“不可说”（undefined behavior 甚至是不合理的语法）的领域中去应用编程语言，他就是能够说明白的。编程语言比起自然语言更严谨，更不容易犯错误，编译器/解释器甚至保证你在编写过程中不越过“不可说”的边界。那么编程语言自举的根基（可说的真理）究竟在哪呢？</p><p>我们尚且不把链接器考虑到我们所说的编程语言的一部分中去，假设这里所指编程语言仅仅是编译器前端。编程语言的工作是，假设我们生成的 IR 能够在一个完美的状态机上运行的情况下，根据所掌握的这一些“真理”，去构建一套语言体系。至此，我们回避了很多的论证，剩下的问题是，一门语言能否描述清楚他自己？</p><p>一门要描述清楚他自己，首先就要求，这们语言是不能讲胡话（nonsense）的，例如一个函数接受 T 类型，返回非 T 的某种类型，这就是胡话。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">A</span></span> = [<span class="built_in">u8</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Any</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Any <span class="keyword">for</span> &amp;A &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_sense</span></span>&lt;T&gt;(input: T) -&gt; T &#123;</span><br><span class="line">    input</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">russell_paradox</span></span>&lt;T&gt;(input: &amp;T) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Any&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">unsafe</span> &#123; *(input <span class="keyword">as</span> *<span class="keyword">const</span> T <span class="keyword">as</span> *<span class="keyword">const</span> &amp;A) &#125;;</span><br><span class="line">    <span class="built_in">Box</span>::new(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> _a = make_sense(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> b = russell_paradox(&amp;<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> c = russell_paradox(&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于“非 T 的某种类型”难以表示，此处用一个 Any 类型来表示（不同于 std::any::Any，这里的 Any 连 type_id 方法都没实现，是一个真正的不知道类型的玩意），我们假设 russell_paradox 这个函数接受类型 T，返回一个类型不是 T 的值，第一次调用这个函数，我们的到了 b，第二次用 b 得到 c，问题是 c 的类型和 b 类型的关系是什么呢？在第一次调用 russell_paradox 函数时，其返回值 b 已经失去类型信息了，而第二次的调用无非是把不知道是什么类型的数据再丢失一次类型，问这两个值的类型关系是什么，是没有意义的。当我们要使用这两个值做任何有类型的的事情时，编译器会立刻阻止我们，除非再一次为它执行定类型。</p><p>我们所说的编程语言，其实是在一个完美的状态机上面运行的，但没有人能够证明这个状态机是完美的，即使 CPU 的电路设计没有问题，因为宇宙射线导致的电位跳动会立即导致我们的程序陷入“不可知”（undefined behavior）的状态，这种“不可知”已经超出了我们的能力范围。</p><p>抛开下层的东西不谈，自举的有趣在于，当我们批评一个自举的论证有错的时候，即是在说它的过程有误、也是在说它的结果和出发点有误。然而指出错误的人本身认可了一套他所指出错误的逻辑（命题）和这些命题所基于的真理。只要从这些命题和真理出发，对自举的论证过程加以修正，就能得到他的语言的边界所指不出错的编程语言和自举过程。</p><p>以上，是我对自举合理性的看法。</p><p>而自然语言的自成性和对不合理过程的论证，似乎平滑的多。我们说“所有的天鹅都是白的”，直到某一天飞出了一只黑天鹅，这时候我们就会把事实（facts）改成“天鹅有白的和黑的”，与此相关的命题都跟着修改，这样我们又得到了一个满足自成性的语言。而自然语言的边界甚广，以至于它无时不存在一个修正的状态。</p><p>我们的现实世界就是这样扩张的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Memoria-2020</title>
    <link href="http://yoursite.com/2021/01/18/memoria-2020/"/>
    <id>http://yoursite.com/2021/01/18/memoria-2020/</id>
    <published>2021-01-18T09:53:00.000Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为从去年年底开始到现在都忙的手忙脚乱，这篇回忆录已经拖了快一个月了，但 2020 还是对自己影响很大的一年，很幸运的认清楚了自己未来要的是什么，故提笔。</p><hr><p>这篇文章 delay 很大原因是参加了 Hackathon。九月中，我转到事务组一段时间后，VLDB 2020 召开了，mentor 把 Proceedings 上一篇讲确定性事务的论文丢给了我。我在对 2pc 理解还不够深刻、对 TiDB 分布式事务实现还不够了解、没听过什么是确定性数据库的情况下囫囵吞枣的读了这篇论文，也成了我了解确定性数据库的入口（对，我事前居然没了解过 Calvin！）。时间推进到十二月初，在学校和导师沟通的过程中发现我原本在研究的基于依赖关系事务模型的测试方法并不能被非数据库方向的答辩评委所认同，于是我想起了这篇文章，恰巧今年的 TiDB Hackathon 进行的比较晚，就打算拿这个 idea 来参赛。好在我的队友和导师非常的厉害，我像海沃德一样提出天真的想法，他们像维克斯一样指出其中的问题，并加以修正。最后这辆确定性事务的车开起来了，一个新的事务模型，影响大到没人敢想象合并到代码库里面去的样子。和论文不同的是，我们的实现需要考虑和现有架构的融合，是一个痛苦且有趣的过程！越是想破脑袋搜刮方案，渴望找出新的解决方式，就越是觉得 2pc 固若金汤、无懈可击，最后是在 Calvin 上找到了 checkpoint 的思路，虽然不知道靠不靠谱，先做一把实验再说。</p><p>印象中每次参加 Hackathon 都会肝到四五点，怀疑人生，这次即使是在有了完整的规划的情况下，还是因为改事务影响的东西太多而爆炸肝。为了跑起来 tpcc，修到半夜，最后又在调优上花费了大量的时间。作为比赛的反思是不应该死磕 tpcc 的，他虽然很重要，但太难了！</p><p>印象最深刻的项目是赛前在推上看到 spdk 的结果 1.8-10x qps，感到相当震惊，我以为这和 utp 一样简直是对其他提升性能工作的降维打击，并且其作者有相当丰富的 kernel 开发经验。IMO, that’s what true hackers do.</p><p>但这终究是比赛，而非学术会议，good idea, implementation, story 缺一不可，我们组的确定性事务和 spdk 一样走了学术派路线。嘛，反正自己玩开心了 lol。</p><hr><p>前些日子和同学一起看了“心灵奇旅”，我个人非常喜欢这个电影的风格，主流的西方文学、影视作品都倾向于写实风格，比如复仇者联盟，通过具像的画面和特效来传达感情。但我更喜欢刘易斯的那种《爱丽丝梦游仙境》的作品，我们在艺术创作中为什么要遵循逻辑呢？我们总是假设自己能了解到真实的东西，而真正的真实是基于所见之物的推理，前者是可以突破的，而后者不行。</p><p>我喜欢这部作品的另一个原因来自与我所崇拜的创作者SCA自所写的剧本。</p><center>なぜ大人はお酒を飲むのか？<br>为什么大人喜欢喝酒呢？<br>大人になると悲しいことに、酒を呑まなくては酔へないからである。<br>大人是非常令人悲伤的，不喝酒就无法进入「醉」的状态。<br>子供なら、何も呑まなくても、忽ち遊びに酔つてしまふことができるのだから……。<br>但是小孩子啊，什么都不需要，只是在玩耍的过程中，就能进入「醉」的状态了...</center><p>电影在这一点上刻画的很好，22 从刚来到世界的迷茫，变化成好奇，任何事情对于 22 来说都是有趣新鲜的，看到汽车觉得“那么大的东西居然会动”，吃批萨会发现“原来有这么好吃的东西”。而很多大人，甚至会拿“不就是汽车”、“不就是批萨”来鄙视他人，这是何等的恶劣和悲伤。</p><p>我对这部电影喜欢的地方也正是我觉得他所刻画不够的地方，简而言之是对 22 在地球的心路历程的变化不够，以及 Joe 的表现未能体现出这一点反差，童年的美在于未知和无限的新奇。我不喜欢在欣赏一部作品的时候从电影制作的视角去看他，这里所说的仅仅是我作为一位观众的意见。</p><hr><p>今年做的一个很重要的决定是 dive into database，我对 CS 的学习过程是自顶向下的一条扭曲的路线，不停的否定自己的认知。和我的天才同事们不同，我没有打过 OI/ACM，在代码能力的起点上有着很大的差距，入门是从前端开发学起的，相比于如何写代码，我更懂如何做产品。相比之下，我比较随遇而安，在来 p 社实习之前，从来没有把数据库开发作为自己的职业选项之一，对数据库没有特殊的兴趣，但是我确实觉得研究数据库的过程非常有趣。在校招的季节，1、我面临两个选择，刷题面试光撒网，2、dive into database。我确信，以我的智商做不到在收获一堆令人羡慕的 offer 的同时还能学好数据库事务，那个时候家里人和我说「你最重要的事情是面试」，但我还是选择了后者。</p><p>老实的说，我是一个不擅长表现自己的人，当面试官问我“介绍一下数据库隔离级别的时候”，但凡我对通过读写关系对事务进行描述有一点不了解的时候，我都会老老实实的搬出教科书上古老的“脏读-序列化”的定义；而对于我很清楚的东西，又会略过细节，去讲述最核心的东西。这也直接导致了我参加的为数不多的面试都迅速结束，说到底还是学艺不精（笑。</p><p>面试是为了得到一个理想的岗位，而我现在又正在一个理想的岗位上实习，本着活在当下的想法，在那个所有同学都在刷题面试的时候，我开始 dive into database。半年后的今天，我也不能说我在数据库领域上有了多高明的见解，总结下来有几点小成就：比起去年 hackathon，能听懂的项目变多了不少；看 issue 能找到一个 bug 出在哪里了；看山不是山了。</p><p>因为某位卷王的原因，「失败」成为了我社交圈里的高频词汇，认真的说我没感觉自己有多「失败」，也没有多「成功」，今年还是在一个「差不多」的状态中过去了，能力不足的原因，想做的事情都没有做的很成功，但拥有了不少「失败」的经验。幸运的是，我至今所打过交道的同事都无比的善良，也给予了我数不清的帮助，让一个没怎么做过系统编程的小白入门了数据库开发，我不觉得适应大厂职场那一套是什么了不起的事情。</p><hr><p>前文提到了我懂得如何做产品，在我看来做产品重要的是「侍奉之心」，渴望把最好的东西给使用者，听到使用者的意见，这其中必然会做许多 dirty 的工作。我没有什么大型产品的打造经验，我说的纯属是做 bot 过程中的一些心得，做出来的东西有人喜欢是一件很令人开心的事，由于 p 社的程序员大多有类似代码洁癖的强迫症，所以他们对工具的要求真的很高！以自动 merge 代码的功能为例，要做到几个要求：同 branch 串行，不同 branch 并行；当需要时自动 update branch；随时暂停。</p><p>在参与数据库开发之后，我发现所谓「侍奉之心」是根本不够用，很多时候也不顶用的，要做好数据库内核，唯有走火入魔的痴迷其中与配当天才的智商。对我的能力来说，这是一条困难的路，也是一条需要抛弃许多东西才能够走的动的路。</p><hr><p>暑假时候入坑了 ff14，但是因为性格原因，对于团队配合的游戏难以上手，时刻担心自己的失误会给队友造成困扰，我认为自己游戏水平至少不低，愿意重复挑战高难度的关卡，比如在玩 mhw 的时候，我是在单人摸清楚贝西摩斯的机制之后才和同学一起挑战的，之后 solo clear 了这只建议团队攻略的怪物。ff14 是相当出色的 MMORPG，并没有因为我不喜欢团队游戏就损失所有的游戏乐趣，其中的元素众多，融合的方式之好甚至想让我去补历作的 ff。</p><hr><p>比起下半年的清晰，上半年的经历可能比较迷茫，虽然国内的疫情控制良好，但口罩和严格的管制政策使城市生活更加的压抑与孤独。在工作中无法找准自己的定位，看到身边同事的优秀感觉遥不可及，感到焦虑和疲惫，至此完全抛弃了在学校里觉得自己什么事情都能做、能做好的那些盲目。感谢某位同事和我说的“做数据库其实没那么难，会写代码就行了”，虽然我不认为我的天才同事们仅仅是「会写代码」而已，但我好像也能「会写代码」，事情是从那时候开始变得清晰的。</p><p>暑假的时候，有位学长给我介绍过选调生，当下不是没有心动过，不加班，没有 KPI/OKR，可以享受生活，我 100% 理解为什么那么多人想当公务员——躺在高速发展的列车上享受人生。当然我远没有那位学长那么优秀，甚至没有选调生的报名资格（笑），在之前的研究生阶段就没有考虑过自己还有这条路可以选择。而另一点，想到了当时司法考试的失败，当年没有影响到考研是我的幸运，我考研成功了，但是如今如果再把心思分散到考公上面去，那就不一定有这种幸运了。自然的、理想主义的想法，公务员并非什么高人一等的岗位，也并非除了这一条路我就无法实现自我，倒不如说，在体制内实现自我对我来说更加困难吧。这是这份心动马上就消散的原因。</p><p>我不怎么清高，也不是不知道显示的高低优劣，只是觉得如果所有人都变成哪里钱多哪里能工作轻松就往哪里扎堆，那这样的世界未免太过枯燥。我们所生活的城市，已经接近于艺术的不毛之地，这一行为是在加剧这种现象而已，哪怕有了十分轻松的工作，上班下班十年如一日，这能算「生活」吗？大部分人认为考公就是脱离苦海的现象挺奇怪的。</p><hr><p>最后，给看到这里的你揭晓一个答案，我的网名是 you06，来源于我接触的第一个网络游戏。</p><p><img src="./you06.png" alt="you06"></p><hr><p>年初开完年会回到家之后，疫情就开始了，当很多同学赋闲并享受了可能是成年以后最长的一个假期的同时我在家经历了 remote 工作的一段时间。这一年过的比我想象中要快，我的忙碌也算不得什么真正的忙碌，感谢帮助和关心过我的人，祝你们能完成自己的心愿。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于「逻辑哲学论」</title>
    <link href="http://yoursite.com/2020/12/19/note-on-tractatus-logico-philosophicus/"/>
    <id>http://yoursite.com/2020/12/19/note-on-tractatus-logico-philosophicus/</id>
    <published>2020-12-19T02:15:00.000Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-yCYrVBqS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-yCYrVBqS"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Jesu, Joy of Man's Desiring",              author: "Gabor Varga Jazz Trio / Szaniszló Richárd",              url: "https://music.163.com/song/media/outer/url?id=1803632058.mp3",              pic: "https://p1.music.126.net/U67QMLrtvwLuhlvyRr_Uhg==/109951165533959970.jpg?param=130y130",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>坦言之，我读「逻辑哲学论」是因为玩了SCA-自老师的作品，而且我也没读懂这本书，但里面所描述的一些关于数学方法以及世界的哲学认知有打动我的地方，所以不妨在这里瞎说几句。「逻辑哲学论」的取命来自于斯宾诺莎的「神学政治论」，希望能够一读。</p><center>人所知道的而非仅由喧嚣扰攘中听来的一切，都可以用三个词说出来。<br>——屈伦伯格尔</center><p>即使是囫囵吞枣地读完全书之后，也是一定可以理解这句话的。关于前几章晦涩难懂的描述，不妨跳过，我认真读了，但是没有什么收获。</p><p>维氏在本书里所提到的许多关于符号、事实、逻辑图像、命题的描述与我们今日所采用的描述已有一定的区别，时而令我觉得眼熟，但尝试去认真理解他们的时候又感受到明显的障碍。但毫无疑问，维氏对于数学的描述是现代的，就像我们所开玩笑说的“1+2 = 2+1 不是因为他们都等于 3，而是因为这是一个阿贝尔群”一样，维氏对数学的描述以至于到哲学论的描述都秉持了这一谨慎的态度。</p><p>「5.6　　 我的语言的界限 意味我的世界的界限。」说出了十分可惜的事，我们不能用语言来描述我的世界，它是有界限的，如果我所说的实体不能被正确的指代，或是我所说的逻辑符号不能被理解成唯一的含义，那语言在这时候就无法描述世界。语言本身也是世界的一部分。如果想要完整的描述世界，那么只能够从世界之外观察。</p><p>「6.341　　 （正如借助数字系统我们能够写出任何数目一样，借助力学系统我们也应该能够写出任何物理学命题。）」，「6.342　　 …同样，世界可以用牛顿力学来描述，这关于世界并无所说；…」，玩过「すばひび」的朋友们还记得「空气力学」嘛？世界当然也可以用「空气力学」来描述，只是可能因为几乎没有付合规律性的命题，所以不能说出来而已。维氏说现代人之于自然规律，就像古代人之于神一样，他们都是正确切错误的，因为他们都不符合「因果律」，那么关于他们是否一定会发生这个命题就是不可说的。从语言的认知上来说，「5.621　 世界和人生是一回事」，但是当我们想要讨论其这些不可知的事情的时候，又会发现「6.373　世界是独立于我的意志的。」，换句话说，人生是独立于我的意志的，我无法把他说的明明白白的。「6.43　 幸福者的世界不同于不幸者的世界。」是因为他们的世界的界限不同，用数学系统描述世界的人和用力学系统描述世界的人和用「空气力学」系统描述世界的人，他们的世界的界限也不同。</p><p>「7　　　对于不可说的东西我们必须保持沉默。」第七章以一句话结尾，回答了卷首的格言，人所知道的都是能够被用三个词说明白的，而其他的，我们不能够说的明白，我们需要对此保持沉默。很有意思的一点是，本书在哲学上的论证，是想要说，当我们想要脱离自然规律讨论形而上学的东西的时候，就已经超过了说话者的世界的界限，我们应该对说话者说“快沉默吧！”。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TiUP 使用指南</title>
    <link href="http://yoursite.com/2020/11/02/tiup-guide/"/>
    <id>http://yoursite.com/2020/11/02/tiup-guide/</id>
    <published>2020-11-02T21:24:32.000Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>TiUP</code>是一个<code>TiDB</code>的组件管理工具，我本人的使用体验是（在会用的情况下）非常好用，可惜有的时候不会用，这里记载一些自己踩过的坑以及常用的使用方法，意在弥补文档不全面的情况。</p><h2 id="TiDB-Playground"><a href="#TiDB-Playground" class="headerlink" title="TiDB Playground"></a>TiDB Playground</h2><p>回想起当时做小作业的时候，为了起一个<code>TiDB</code>集群，不管是用<code>TiDB</code>的<code>Ansible</code>还是<code>Docker Compose</code>都对我这个萌新（和低配 Mac）非常不友好，直到<code>TiUP</code>问世。</p><p>从<code>TiUP Playground</code>最基本的使用方式说起，不加任何参数启动<code>Playground</code>，会看到以下结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">» tiup playground</span><br><span class="line">...</span><br><span class="line">Start tiflash instance</span><br><span class="line">...</span><br><span class="line">CLUSTER START SUCCESSFULLY, Enjoy it ^-^</span><br><span class="line">To connect TiDB: mysql --host 127.0.0.1 --port 37257 -u root</span><br><span class="line">To view the dashboard: http://127.0.0.1:2379/dashboard</span><br><span class="line">To view the Prometheus: http://127.0.0.1:9090</span><br><span class="line">To view the Grafana: http://127.0.0.1:3000</span><br></pre></td></tr></table></figure><p>其实我起<code>Playground</code>大部分时候只是想做一些功能性测试，并不希望看到<code>Prometheus</code>和<code>Grafana</code>以及<code>tiflash</code>，所以我常用的命令是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiup playground --tiflash=0 --monitor=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>在使用<code>Ctrl + C</code>发送<code>SIGINT</code>时，会看到<code>TiUP</code>进程卡在了这样一个状态，正在等待某某某进程退出，然后下一个，到全部退出可能要花费十多秒的时间，主要是等待<code>TiDB</code>退出的时间特别长，以及<code>TiUP</code>会删除掉<code>TiDB</code>集群所生成的文件。使用<code>Ctrl + C</code>发送第二个<code>SIGINT</code>信号会让<code>Playground</code>和它所拉起来的进程强制退出（<code>SIGKILL</code>）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^CPlayground receive signal:  interrupt</span><br><span class="line">Got signal interrupt (Component: playground ; PID: 6355)</span><br><span class="line">Wait pd(6377) to quit...</span><br><span class="line">pd quit</span><br><span class="line">Wait tikv(6383) to quit...</span><br><span class="line">tikv quit</span><br><span class="line">Wait tidb(6385) to quit...</span><br><span class="line">tidb quit</span><br></pre></td></tr></table></figure><h2 id="TiDB-Cluster"><a href="#TiDB-Cluster" class="headerlink" title="TiDB Cluster"></a>TiDB Cluster</h2><p>如果要起一个生产环境用的集群，需要使用<code>TiDB Cluster</code>这个组件，当然我不是专业的DBA，也没有在生产环境实践过，这里所说的，是一个程序员启动一个开发用集群的实践。主要流程请参考<a href="https://docs.pingcap.com/zh/tidb/stable/tiup-cluster">官方文档</a>，本文只写自己遇到的坑。</p><h3 id="1-编辑拓扑文件"><a href="#1-编辑拓扑文件" class="headerlink" title="1. 编辑拓扑文件"></a>1. 编辑拓扑文件</h3><p>最初写<code>TiUP</code>的拓扑文件，因为找不到文档，所以对着代码里的结构体定义在写，写的十分痛苦，建议直接抄 example： <a href="https://github.com/pingcap/tiup/blob/master/examples/topology.example.yaml">https://github.com/pingcap/tiup/blob/master/examples/topology.example.yaml</a> 。</p><h3 id="2-部署启动集群"><a href="#2-部署启动集群" class="headerlink" title="2. 部署启动集群"></a>2. 部署启动集群</h3><p>认真看官方文档的小伙伴，应该不用来这里抄命令了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">» tiup cluster deploy ntr nightly topology.yaml</span><br><span class="line">» tiup cluster list</span><br><span class="line">Name          User  Version  Path                                                      PrivateKey</span><br><span class="line">----          ----  -------  ----                                                      ----------</span><br><span class="line">ntr           tidb  nightly  /home/tidb/.tiup/storage/cluster/clusters/ntr             ...</span><br><span class="line">» tiup cluster start ntr</span><br></pre></td></tr></table></figure><h3 id="3-patch"><a href="#3-patch" class="headerlink" title="3. patch"></a>3. patch</h3><p>有的时候想要测试自己编译的组件，<code>TiUP</code>提供了<code>patch</code>命令，但是大家非常容易翻一个常见错误，以<code>TiDB</code>为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">» tiup cluster patch ntr tidb-server -R tidb</span><br><span class="line">...</span><br><span class="line">Starting component `cluster`: /home/tidb/.tiup/components/cluster/v1.2.0/tiup-cluster patch ntr tidb-server -R tidb</span><br><span class="line"></span><br><span class="line">Error: <span class="built_in">exit</span> status 2</span><br><span class="line"></span><br><span class="line">Verbose debug logs has been written to /home/tidb/tiup/logs/tiup-cluster-debug-2077-11-04-05-14-00.log.</span><br><span class="line">Error: run `/home/tidb/.tiup/components/cluster/v1.2.0/tiup-cluster` (wd:/home/you06/.tiup/data/SFC8xCY) failed: <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure><p>因为根据 DBA 的使用习惯，一般想要直接使用下载下来的 tar 包，所以 patch 命令所指定的文件也需要是一个 tar 包（快兼容一下啊(╯‵□′)╯︵┻━┻）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar czf tidb-server.tar.gz tidb-server</span><br><span class="line">tiup cluster patch ntr tidb-server -R tidb</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>yasp 开发日记【2】</title>
    <link href="http://yoursite.com/2020/08/17/yasp-diary-2/"/>
    <id>http://yoursite.com/2020/08/17/yasp-diary-2/</id>
    <published>2020-08-17T14:25:50.000Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="/2020/06/01/yasp-diary-1/">yasp 开发日记【1】</a>提到了我遇到关键字 ambiguous 的问题，这个问题在<code>lalrpop</code>的<a href="https://lalrpop.github.io/lalrpop/lexer_tutorial/001_lexer_gen.html#precedence-of-fixed-strings">Precedence of fixed strings</a>章节也有所描述，并提供了解决方法。</p><p><code>SQL</code>语言是一个流行的关键字大小写不敏感的语言，例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> uta <span class="keyword">from</span> sakura;</span><br><span class="line"><span class="keyword">SeLecT</span> uta <span class="keyword">fRom</span> sakura;</span><br></pre></td></tr></table></figure><p>这两句<code>SQL</code>的语义实际上是一样的，但是如果我们这么写一个简陋的<code>lexer</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Name: String &#x3D; r&quot;\w+&quot; &#x3D;&gt; &lt;&gt;.into();</span><br><span class="line">SELECT: &amp;&#39;input str &#x3D; &quot;select&quot; &#x3D;&gt; &lt;&gt;;</span><br><span class="line">FROM: &amp;&#39;input str &#x3D; &quot;from&quot; &#x3D;&gt; &lt;&gt;;</span><br><span class="line">pub Expr: Expr &#x3D; &#123;</span><br><span class="line">    SELECT &lt;field: Name&gt; FROM &lt;table: Name&gt; &#x3D;&gt; Expr::Select(SelectNode&#123;</span><br><span class="line">        field,</span><br><span class="line">        table,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这个<code>lexer</code>对于<code>select uta from sakura</code>来说没问题；但是对于<code>SeLecT uta fRom sakura</code>来说，<code>SeLecT</code>和<code>fRom</code>不能够被匹配成关键字。</p><p>需要注意的另一点是，根据<a href="https://lalrpop.github.io/lalrpop/lexer_tutorial/001_lexer_gen.html#precedence-of-fixed-strings">Precedence of fixed strings</a>的描述，固定的字符串拥有比正则表达式更高的匹配优先级，所以这个词法分析器不存在歧义。</p><p>为了匹配<code>SeLecT</code>和<code>fRom</code>关键字，我们将<code>lexer</code>改成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Name: String &#x3D; r&quot;\w+&quot; &#x3D;&gt; &lt;&gt;.into();</span><br><span class="line">SELECT: &amp;&#39;input str &#x3D; r&quot;(?i)select&quot; &#x3D;&gt; &lt;&gt;;</span><br><span class="line">FROM: &amp;&#39;input str &#x3D; r&quot;(?i)from&quot; &#x3D;&gt; &lt;&gt;;</span><br><span class="line">pub Expr: Expr &#x3D; &#123;</span><br><span class="line">    SELECT &lt;field: Name&gt; FROM &lt;table: Name&gt; &#x3D;&gt; Expr::Select(SelectNode&#123;</span><br><span class="line">        field,</span><br><span class="line">        table,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，<code>lalrpop</code>会认为我们所描述的语法存在歧义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: ambiguity detected between the terminal &#96;r#&quot;\\w+&quot;#&#96; and the terminal &#96;r#&quot;(?i)from&quot;#&#96;</span><br></pre></td></tr></table></figure><p>好吧，<code>lalrpop</code>不会处理推断多个正则表达式之间的优先级，相应的，文档中也给出了处理方式——预处理输入。</p><p>需要这样修改<code>lexer</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">match &#123;</span><br><span class="line">    r&quot;(?i)select&quot; &#x3D;&gt; &quot;SELECT&quot;,</span><br><span class="line">    r&quot;(?i)from&quot; &#x3D;&gt; &quot;FROM&quot;,</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    _</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Name: String &#x3D; r&quot;\w+&quot; &#x3D;&gt; &lt;&gt;.into();</span><br><span class="line">SELECT: &amp;&#39;input str &#x3D; &quot;SELECT&quot; &#x3D;&gt; &lt;&gt;;</span><br><span class="line">FROM: &amp;&#39;input str &#x3D; &quot;FROM&quot; &#x3D;&gt; &lt;&gt;;</span><br><span class="line">pub Expr: Expr &#x3D; &#123;</span><br><span class="line">    SELECT &lt;field: Name&gt; FROM &lt;table: Name&gt; &#x3D;&gt; Expr::Select(SelectNode&#123;</span><br><span class="line">        field,</span><br><span class="line">        table,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然<code>lalrpop</code>不会自动推断多个正则表达式之间的优先级，但是在<code>match else</code>中，我们可以手动指定这些<code>token</code>的优先级。另外，这个写法也将关键词罗列在了一起，让代码可读性变的更强。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TiDB 事务原理 - 点查询</title>
    <link href="http://yoursite.com/2020/07/29/tidb-txn-point-get/"/>
    <id>http://yoursite.com/2020/07/29/tidb-txn-point-get/</id>
    <published>2020-07-29T07:39:45.000Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近来在阅读<code>TiDB</code>事务方面的代码，所以写一些学习记录。</p><p>点查询指的是获取单条数据的<code>SQL</code>语句，相比于范围查询，点查询的执行过程要简单很多，原因有以下几点：</p><ul><li>点查询的结果只可能在一个 region 内</li><li>点查询只会涉及到一个 key 上的锁处理</li></ul><p>将<code>TiDB</code>测试用例中的点查询稍作修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> point (id <span class="type">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>, c <span class="type">int</span>, d <span class="type">varchar</span>(<span class="number">10</span>), <span class="keyword">unique</span> c_d (c, d));</span><br><span class="line"><span class="keyword">insert</span> point <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> point <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> point <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> point <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> d <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在完成建表和插入数据后，我们进行了两个查询，其中第一条<code>SQL</code>可以通过在主键<code>id</code>的等于条件查询条件知道最多有一条结果；第二条<code>SQL</code>可以通过<code>c</code>和<code>d</code>的等于查询条件结合<code>unique c_d (c, d)</code>的约束知道最多有一条结果。然而在实际执行时，还需要考虑许多情况。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><h3 id="构造-key"><a href="#构造-key" class="headerlink" title="构造 key"></a>构造 key</h3><p>我们先在不考虑优化的情况下谈论执行过程（即严格按照<code>SI</code>的含义，对点查询取一个单独的快照来执行），<code>TiKV</code>是一个分布式<code>KV</code>数据库，即想要在<code>TiKV</code>中查出值来，首先需要有一个<code>key</code>，所以要先在<code>TiDB</code>里面把<code>key</code>给构造出来。</p><p>这里以<code>point(id int primary key, c int, d varchar(10), unique c_d (c, d))</code>表为例，有两种构造出点查询的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> point <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">key:</span><br><span class="line">  <span class="number">74</span> <span class="number">800000000000002</span>d <span class="number">5</span>f72  <span class="number">8000000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> point <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> d <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">key:</span><br><span class="line">  <span class="number">74</span> <span class="number">800000000000002</span>d <span class="number">5</span>f69  <span class="number">8000000000000001</span> <span class="number">038000000000000002</span> <span class="number">016200000000000000</span>f8</span><br><span class="line">  <span class="number">74</span> <span class="number">800000000000002</span>d <span class="number">5</span>f72  <span class="number">8000000000000002</span></span><br></pre></td></tr></table></figure><p>为了分析便利，这里列出了接下来可能会用到的<code>ASCII</code>表的内容。</p><table><thead><tr><th>16进制</th><th>字符</th></tr></thead><tbody><tr><td>0x5f</td><td>_</td></tr><tr><td>0x62</td><td>b</td></tr><tr><td>0x69</td><td>i</td></tr><tr><td>0x72</td><td>r</td></tr><tr><td>0x74</td><td>t</td></tr></tbody></table><p>对于第一条查询，因为<code>point</code>表中的主键字段为<code>id</code>，所以能够直接通过<code>id</code>来构造<code>key</code>；而对于第二条查询，我们只知道<code>c</code>和<code>d</code>的约束条件，需要先通过已知的条件确定主键的值再进行查询。</p><p>我有意的将<code>key</code>拆成了几段来进行分析</p><ul><li><p>第一段<code>74 800000000000002d 5f72</code>和<code>74 800000000000002d 5f69</code></p></li><li><p>第二段<code>8000000000000001</code>和<code>8000000000000001 038000000000000002 016200000000000000 f8</code></p></li></ul><h4 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h4><p><code>74 800000000000002d 5f72</code>和<code>74 800000000000002d 5f69</code>是两种查询类型，其中还包括了表信息。</p><p>其中<code>800000000000002d</code>代表了表<code>id</code>，用<code>int64</code>来表示，但是在编码的时候把符号位强行置为了1。</p><p>查<code>ASCII</code>表之后，我们可以将这两个<code>key</code>写成<code>t45_r</code>和<code>t45_i</code>，可以参考以下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/pingcap/tidb/tablecodec/tablecodec.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">tablePrefix     = []<span class="keyword">byte</span>&#123;<span class="string">&#x27;t&#x27;</span>&#125;</span><br><span class="line">recordPrefixSep = []<span class="keyword">byte</span>(<span class="string">&quot;_r&quot;</span>)</span><br><span class="line">indexPrefixSep  = []<span class="keyword">byte</span>(<span class="string">&quot;_i&quot;</span>)</span><br><span class="line">metaPrefix      = []<span class="keyword">byte</span>&#123;<span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么很容易理解，<code>recordPrefixSep</code>是要查询记录，而<code>indexPrefixSep</code>是要查询索引，回到上面，<code>select * from point where c = 2 and d = &#39;b&#39;</code>这条<code>SQL</code>要经过两次查询，第一次通过<code>unique</code>索引查询到主键索引，第二次再通过主键索引查询记录值。</p><h4 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h4><p>根据刚才的分析，<code>8000000000000001</code>很容易理解，指的就是索引（这里是<code>id</code>列）的值。</p><p><code>8000000000000001 038000000000000002 016200000000000000 f8</code>是一条对索引进行查询的<code>key</code>的值。</p><ul><li><code>8000000000000001</code>代表的是索引的<code>id</code>（即使在一张表内也可能存在多个索引）</li><li><code>038000000000000002</code>中<code>03</code>代表是整数类型，<code>8000000000000002</code>代表查询的值为2</li><li><code>016200000000000000f8</code>中<code>01</code>代表是<code>bytes</code>类型，<code>6200000000000000f8</code>是字符串<code>b</code>编码后的结果，<code>0x62</code>是<code>b</code>，后面一串<code>0</code>是为了对齐，最后的<code>0xf8</code>表示 padding 长度，此处为 7，<code>0xff - 7 = 0xf8</code>，详细的编码方式可以参考 <a href="https://github.com/pingcap/tidb/blob/b16c46dba91eb05b5d60c92d185443ead8f40394/util/codec/bytes.go#L34-L68">TiDB代码</a></li></ul><h3 id="查询-key"><a href="#查询-key" class="headerlink" title="查询 key"></a>查询 key</h3><p>在有了<code>key</code>之后，<code>TiDB</code>会向对应<code>region</code>所在的<code>TiKV leader</code>发出<code>RPC</code>请求，此时，我们的问题变成了如何从一个带有分布式事务的<code>KV</code>存储引擎上查询一个<code>key</code>。</p><p><code>KV</code>存储引擎需要考虑的问题：</p><ul><li>1 如果尝试读取一个正在<code>commit</code>中的<code>key</code>，并且<code>commit ts</code>小于<code>get ts</code>，那么应该读到<code>commit</code>完成之后的值</li><li>2 处理 Internal Read 的情况</li></ul><p><code>TiKV</code>会首先拿取一个<code>snapshot</code>，然后检查这个<code>key</code>上存在的锁，锁信息存在一个叫<code>lock</code>的<code>CF</code>中，如果存在锁，则说明这个值可能有变化，即上面所说的问题1，此时<code>TiKV</code>会将标志位<code>met_newer_ts_data</code>从<code>NotMetYet</code>改为<code>Met</code>，然后执行<code>check_ts_conflict</code>函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Checks whether the lock conflicts with the given `ts`. If `ts == TimeStamp::max()`, the primary lock will be ignored.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">check_ts_conflict</span></span>(<span class="keyword">self</span>, key: &amp;Key, ts: TimeStamp, bypass_locks: &amp;TsSet) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 1. 锁的 ts 大于 snapshot 的 ts，显然应该忽略这把锁</span></span><br><span class="line">    <span class="comment">// 2. 锁有四种类型 Put, Delete, Lock, Pessimistic，后两种和数据无关，忽略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.ts &gt; ts</span><br><span class="line">        || <span class="keyword">self</span>.lock_type == LockType::Lock</span><br><span class="line">        || <span class="keyword">self</span>.lock_type == LockType::Pessimistic</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Ignore lock when lock.ts &gt; ts or lock&#x27;s type is Lock or Pessimistic</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put 或 Delete 记录的最小 commit ts 大于 snapshot 的 ts，snapshot 读不到这个数据更新</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.min_commit_ts &gt; ts &#123;</span><br><span class="line">        <span class="comment">// Ignore lock when min_commit_ts &gt; ts</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个 internal read，直接读取未 commit 的数据即可，例</span></span><br><span class="line">    <span class="comment">// begin</span></span><br><span class="line">    <span class="comment">// write(x, 1)</span></span><br><span class="line">    <span class="comment">// read(x)</span></span><br><span class="line">    <span class="keyword">if</span> bypass_locks.contains(<span class="keyword">self</span>.ts) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> raw_key = key.to_raw()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为什么可以忽略这把锁，这里我也没看懂...</span></span><br><span class="line">    <span class="keyword">if</span> ts == TimeStamp::max() &amp;&amp; raw_key == <span class="keyword">self</span>.primary &#123;</span><br><span class="line">        <span class="comment">// When `ts == TimeStamp::max()` (which means to get latest committed version for</span></span><br><span class="line">        <span class="comment">// primary key), and current key is the primary key, we ignore this lock.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至此，锁生效了，这里的 Err 会直接返回给发送 get rpc 请求的客户端（TiDB）</span></span><br><span class="line">    <span class="comment">// 这个查询会在 TiDB 里面被重试</span></span><br><span class="line">    <span class="comment">// There is a pending lock. Client should wait or clean it.</span></span><br><span class="line">    <span class="literal">Err</span>(Error::from(ErrorInner::KeyIsLocked(</span><br><span class="line">        <span class="keyword">self</span>.into_lock_info(raw_key),</span><br><span class="line">    )))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过锁检查后，<code>met_newer_ts_data</code>这个标志位可能会有两种状态，<code>NotMetYet</code>和<code>Met</code>。</p><p>对于<code>NotMetYet</code>的情况，没有遇到这个<code>key</code>上存在的锁，所以只需要拿取最新数据就可以了。取数据的过程涉及到<code>MVCC</code>的操作，这里不会对其详细介绍（其实我也不大懂），可以参考<a href="https://pingcap.com/blog-cn/tikv-source-code-reading-13/">TiKV 源码解析系列文章（十三）MVCC 数据读取</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> use_near_seek = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> seek_key = user_key.clone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.met_newer_ts_data == NewerTsCheckState::NotMetYet &#123;</span><br><span class="line">    <span class="comment">// 将 ts 置为 max，找到 lower_bound 的位置</span></span><br><span class="line">    <span class="comment">// 如果找不到，说明 key 不存在</span></span><br><span class="line">    seek_key = seek_key.append_ts(TimeStamp::max());</span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span></span><br><span class="line">        .write_cursor</span><br><span class="line">        .seek(&amp;seek_key, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write)?</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把刚才写入的 TimeStamp::max() 删掉，在 lower_bound 附近寻找目标版本</span></span><br><span class="line">    seek_key = seek_key.truncate_ts()?;</span><br><span class="line">    use_near_seek = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cursor_key = <span class="keyword">self</span>.write_cursor.key(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write);</span><br><span class="line">    <span class="comment">// lower_bound 的 key 不等于要查询的 user_key（为什么没有在上面就返回 Ok(None) 0.0），感觉这里理解有误</span></span><br><span class="line">    <span class="keyword">if</span> !Key::is_user_key_eq(cursor_key, user_key.as_encoded().as_slice()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遇到了新数据！</span></span><br><span class="line">    <span class="keyword">if</span> Key::decode_ts_from(cursor_key)? &gt; <span class="keyword">self</span>.ts &#123;</span><br><span class="line">        <span class="keyword">self</span>.met_newer_ts_data = NewerTsCheckState::Met;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seek_key = seek_key.append_ts(<span class="keyword">self</span>.ts);</span><br><span class="line"><span class="comment">// 刚才用过 seek 的情况只需要 near_seek 就可以了</span></span><br><span class="line"><span class="keyword">let</span> data_found = <span class="keyword">if</span> use_near_seek &#123;</span><br><span class="line">    <span class="keyword">self</span>.write_cursor</span><br><span class="line">        .near_seek(&amp;seek_key, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write)?</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.write_cursor</span><br><span class="line">        .seek(&amp;seek_key, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write)?</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> !data_found &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 statistics.write，直到遇到 Put 和 Delete 记录，逻辑真的没看懂...</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// We may seek to another key. In this case, it means we cannot find the specified key.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> cursor_key = <span class="keyword">self</span>.write_cursor.key(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write);</span><br><span class="line">        <span class="keyword">if</span> !Key::is_user_key_eq(cursor_key, user_key.as_encoded().as_slice()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.statistics.write.processed += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> write = WriteRef::parse(<span class="keyword">self</span>.write_cursor.value(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write))?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> write.write_type &#123;</span><br><span class="line">        WriteType::Put =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.omit_value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(<span class="built_in">vec!</span>[]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小于 64 bytes 的数据会被直接放在 write CF 里</span></span><br><span class="line">            <span class="comment">// 否则需要去 default CF 里获取</span></span><br><span class="line">            <span class="keyword">match</span> write.short_value &#123;</span><br><span class="line">                <span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// Value is carried in `write`.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(value.to_vec()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> start_ts = write.start_ts;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">Some</span>(<span class="keyword">self</span>.load_data_from_default_cf(start_ts, user_key)?));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据已被删除</span></span><br><span class="line">        WriteType::Delete =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        WriteType::Lock | WriteType::Rollback =&gt; &#123;</span><br><span class="line">            <span class="comment">// Continue iterate next `write`.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.write_cursor.next(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.statistics.write) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emm 这 blog 写着写着发现挖了好多坑，搞懂之后一定填…</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2020 年中游戏评价</title>
    <link href="http://yoursite.com/2020/07/21/2020-mid-games-review/"/>
    <id>http://yoursite.com/2020/07/21/2020-mid-games-review/</id>
    <published>2020-07-21T12:40:00.000Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我玩过的游戏"><a href="#我玩过的游戏" class="headerlink" title="我玩过的游戏"></a>我玩过的游戏</h2><ul><li><p>サクラノ詩 －櫻の森の上を舞う－</p></li><li><p>ポケットモンスター ソード</p></li><li><p>十三機兵防衛圏</p></li><li><p>CROSS†CHANNEL</p></li><li><p>Ever17 -the out of infinity-</p></li><li><p>美少女万華鏡 -理と迷宮の少女-</p></li><li><p>ATRI -My Dear Moments-</p></li></ul><h2 id="我在玩的游戏"><a href="#我在玩的游戏" class="headerlink" title="我在玩的游戏"></a>我在玩的游戏</h2><ul><li><p>ファイナルファンタジーⅩⅣ</p></li><li><p>PERSONA5 SCRAMBLE The Phantom Strikers</p></li><li><p>きっと、澄みわたる朝色よりも、</p></li></ul><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>今年玩的游戏不算多也不算少，虽然上半年工作繁忙，还是抽了些时间来摸鱼，但整体游戏质量都不错。</p><h3 id="神作（需要珍惜，玩一部少一部）"><a href="#神作（需要珍惜，玩一部少一部）" class="headerlink" title="神作（需要珍惜，玩一部少一部）"></a>神作（需要珍惜，玩一部少一部）</h3><ul><li>サクラノ詩 －櫻の森の上を舞う－</li></ul><p>SCA-自老师（下称扶她自）时隔多年推出的与前作（素晴日）风格截然不同的纯爱作品，适合一个人在深夜慢慢享受，叙事节奏很慢，但是剧情设计非常巧妙。本作艺术气息浓厚，充满着作者对于艺术见解的“私货”，其中扶她自将艺术和青春恋爱故事结合起来的手段非常高明。</p><p>在一个恋爱故事中，将所有的角色写活是件很难的事（写成白色相簿1/2那样免不了带来一片争议），而女主傻白甜或者写成姬野家的女人也不大能成为神作。樱之诗是一部入戏很深的作品，从雫线揭露历史事件开始到真结局，前面单调的剧情都变成了感动，每个角色对于艺术的追求不同，演变出了这个故事。</p><p>松本文纪的音乐从来不令人失望，素晴日偏冷，樱之诗偏暖，奔着音乐去玩也是可以的。</p><p>最后一个小八卦，御桜稟的生日和狗神煌在同一天（5月14日），这部作品可能是扶她自写给狗神煌的情书也说不定…</p><ul><li>Ever17 -the out of infinity-</li></ul><p>凡人想象力之极限，没有一句废话的作品。“没玩完等于没玩”的评价也很符合这部作品，前篇的剧情已经很强，但揭露结局时候的震撼远超前篇，所有的前奏都是为了 true end 做准备，没有缺点的作品。</p><p>游玩可以看不剧透攻略，不要和群友讨论，一句剧透就能让这部作品索然无味。</p><details><summary>以下剧透</summary><p>本作把障眼法运用到了极致，先前玩过素晴日，我以为少年和武视点只是观看视角不同所带来的差异，沙罗和可可像是若槻姐妹般的幻视区别。</p><p>八百比丘尼的故事给我的印象最深，初玩到这段的时候以为就是一些无所谓的剧情，打完之后恍然大悟。</p><p>可可所看见的第三视点带来了不少悬疑元素，配合那个跳动的生命数量，前期想破脑袋。</p><p>每条线都带来了不少情报，虽然是分支线路，但是结局给人的感觉又像是单线一样，这些不同时间轴的分支所带来的情报拼凑在一起，完成了一块立体的拼图。</p></details><h3 id="佳作"><a href="#佳作" class="headerlink" title="佳作"></a>佳作</h3><ul><li>十三機兵防衛圏</li></ul><p>算不上神作，但绝对值得一玩的作品。虽然“拳打石头门，脚踢 E17”的说法过于夸张，但2019年还能推出这种大胆的题材十分了不起。</p><p>战斗重复度过高，打多了比较精污，但其中第三大关关底 boss 战的音乐演绎十分出彩，一边听着少女的歌声一边操作机甲，这就是男人的浪漫啊！</p><p>建议一口气打掉，因为有十三个主角还打乱了时间线，前期会弄不清谁是谁，长时间不玩的话每次回去玩的时候也会比较懵。</p><p>美术风格可以给满分，暗黄的画风带给人上世纪末、本世纪初的街道的感觉，是最初我看上这个游戏的原因之一。</p><p>有华哥。</p><ul><li>CROSS†CHANNEL</li></ul><p>口三才对孤独做出解释的作品，剧情过半就知道结局，但也只能无奈看着事情如此进展，打完之后很空虚。</p><p>没有太多猎奇和电波，想要表达的东西非常单纯，游戏前期比较冗长，但也绝对值得打完之后给自己的那一拳。</p><p>这部作品在深夜一个人打完多少会有些同感吧，愿你能够享受孤独。</p><ul><li>美少女万華鏡 -理と迷宮の少女-</li></ul><p>前四部在我心中的排名是 3 &gt; 2 &gt; 1 = 4 左右，本作收官之作的价值大于其本身的作品水平。可以说是前几作铺垫的好（你管那个叫铺垫？）才造就了镜5的感动（虽然这个感动都被后期剧情给艹飞了）。</p><p>但无论如何，这是我的青春，刚接触这系列作品的适合还只出到2，镜4是我打完的第一部生肉作品。镜系列完结了，青春陨落了。</p><ul><li>きっと、澄みわたる朝色よりも、</li></ul><p>我玩这部游戏的战线拉得很长，总是没事干了突然想到这部游戏我还没打完，于是接着打。回想起来，这个游戏所设定出的场景非常罕见，和樱之诗一样，也是属于很安静的讲故事，同时音乐又给游戏带来加成，属于观感很棒的游戏。</p><p>另外本作的角色取命非常有意思，举个例子，肆则家的两姐妹，肆则家在游戏里的设定是以规则去运营医学的家族。</p><ul><li><p>肆则澄佳 四则乘加</p></li><li><p>肆则楚玪 四则除减</p></li></ul><p>这是一部单线游戏，不需要花心思把每条线都做得巧妙绝伦，前期的支线都是为了最后的主线服务，治好了我的选择困难症。</p><ul><li>ODIN SPHERE LEIFTHRASIR</li></ul><p>奥丁领域，和十三機兵防衛圏一样是香草社的作品，和十三機兵一样，存在战斗重复度过高的情况（可能是本肥宅不喜欢战斗），目前进度不多。优点是画风很淳朴，把北欧神话和童话结合起来，这一点的体验非常棒。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
    <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>yasp 开发日记【1】</title>
    <link href="http://yoursite.com/2020/06/01/yasp-diary-1/"/>
    <id>http://yoursite.com/2020/06/01/yasp-diary-1/</id>
    <published>2020-06-01T23:23:23.000Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/Airyworks/yasp"><code>yasp</code></a>(Yet Another SQL Parser) 是一个<code>SQL</code>解析工具，此前我用<a href="https://github.com/pingcap/parser"><code>TiDB Parser</code></a> 用得很爽，但是用<code>TiDB Parser</code>写测试工具存在一个固有问题是测试工具嫖了被测对象的代码是不合理的。本着严谨科学（和主要是喜欢造轮子）的态度，开了个<code>SQL Parser</code>（下简称<code>Parser</code>）的坑。</p><p>起初我打算用<a href="https://github.com/lalrpop/lalrpop"><code>lalrpop</code></a>一把梭，词法语法一起做了，但是这玩意的词法分析有个小坑是正则匹配不能冲突，以<code>SELECT</code>语句的解析为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Comma&lt;T&gt;: Vec&lt;T&gt; &#x3D; &#123;</span><br><span class="line">    &lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt; &lt;e:T?&gt; &#x3D;&gt; match e &#123;</span><br><span class="line">        None&#x3D;&gt; v,</span><br><span class="line">        Some(e) &#x3D;&gt; &#123;</span><br><span class="line">            v.push(e);</span><br><span class="line">            v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Name: CIStr &#x3D; r&quot;[0-9a-zA-Z_]+&quot; &#x3D;&gt; &lt;&gt;.into();</span><br><span class="line"></span><br><span class="line">pub Fields &#x3D; Comma&lt;Field&gt;;</span><br><span class="line"></span><br><span class="line">pub Field: Field &#x3D; &#123;</span><br><span class="line">    &quot;*&quot; &#x3D;&gt; Field::new_all(),</span><br><span class="line">    Name &#x3D;&gt; Field::new_column(&lt;&gt;),</span><br><span class="line">    &lt;table: Name&gt;&quot;.&quot;&lt;column: Name&gt; &#x3D;&gt; Field::new_column(column).with_table(table),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ResultTable &#x3D; Name;</span><br><span class="line"></span><br><span class="line">pub Expr: Expr &#x3D; &#123;</span><br><span class="line">    &quot;select&quot; &lt;fields: Fields&gt; &quot;from&quot; &lt;result_table: ResultTable&gt; &#x3D;&gt; Expr::Select(SelectNode&#123;</span><br><span class="line">        fields,</span><br><span class="line">        result_table,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><details><summary>完整代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">use crate::ast::&#123;</span><br><span class="line">    dml::*,</span><br><span class="line">    expr::*,</span><br><span class="line">    model::*</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">grammar;</span><br><span class="line"></span><br><span class="line">Comma&lt;T&gt;: Vec&lt;T&gt; &#x3D; &#123;</span><br><span class="line">    &lt;mut v:(&lt;T&gt; &quot;,&quot;)*&gt; &lt;e:T?&gt; &#x3D;&gt; match e &#123;</span><br><span class="line">        None&#x3D;&gt; v,</span><br><span class="line">        Some(e) &#x3D;&gt; &#123;</span><br><span class="line">            v.push(e);</span><br><span class="line">            v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semicolon&lt;T&gt;: Vec&lt;T&gt; &#x3D; &#123;</span><br><span class="line">    &lt;mut v:(&lt;T&gt; &quot;;&quot;)*&gt; &lt;e:T?&gt; &#x3D;&gt; match e &#123;</span><br><span class="line">        None&#x3D;&gt; v,</span><br><span class="line">        Some(e) &#x3D;&gt; &#123;</span><br><span class="line">            v.push(e);</span><br><span class="line">            v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pub Exprs &#x3D; Semicolon&lt;Expr&gt;;</span><br><span class="line"></span><br><span class="line">pub Expr: Expr &#x3D; &#123;</span><br><span class="line">    &quot;select&quot; &lt;fields: Fields&gt; &quot;from&quot; &lt;result_table: ResultTable&gt; &#x3D;&gt; Expr::Select(SelectNode&#123;</span><br><span class="line">        fields,</span><br><span class="line">        result_table,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Name: CIStr &#x3D; r&quot;[0-9a-zA-Z_]+&quot; &#x3D;&gt; &lt;&gt;.into();</span><br><span class="line"></span><br><span class="line">pub Fields &#x3D; Comma&lt;Field&gt;;</span><br><span class="line"></span><br><span class="line">pub Field: Field &#x3D; &#123;</span><br><span class="line">    &quot;*&quot; &#x3D;&gt; Field::new_all(),</span><br><span class="line">    Name &#x3D;&gt; Field::new_column(&lt;&gt;),</span><br><span class="line">    &lt;table: Name&gt;&quot;.&quot;&lt;column: Name&gt; &#x3D;&gt; Field::new_column(column).with_table(table),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ResultTable &#x3D; Name;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>这是一个简单<code>SELECT</code>语句的语法分析，从上往下看。</p><ul><li><code>Comma</code>模板用于处理被逗号分隔的不定长项</li><li><code>Name</code>是一个匹配自定义字段名称的符号</li><li><code>Field</code>分析了<code>*</code>，<code>column</code>，<code>table.column</code>这三种情况</li><li><code>Fields</code>分析<code>SELECT</code>的多个目标字段</li><li><code>Expr</code>是一个简单的<code>SELECT</code>语法构成</li></ul><p>这段代码的问题在于，<code>Expr</code>内部的<code>select</code>和<code>from</code>是固定关键词匹配，而<code>SQL</code>是一个关键词兼容大小写的语言，所以我们需要将其改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub Expr: Expr &#x3D; &#123;</span><br><span class="line">    r&quot;(?i)select&quot; &lt;fields: Fields&gt; r&quot;(?i)from&quot; &lt;result_table: ResultTable&gt; &#x3D;&gt; Expr::Select(SelectNode&#123;</span><br><span class="line">        fields,</span><br><span class="line">        result_table,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过正则来匹配大小写的形式，看起来不错，但是编译却报错了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~/workspace/rust/yasp(refactor*) » cargo <span class="built_in">test</span></span><br><span class="line">   Compiling yasp v0.1.0 (/home/you06/workspace/rust/yasp)</span><br><span class="line">error: failed to run custom build <span class="built_in">command</span> <span class="keyword">for</span> `yasp v0.1.0 (/home/you06/workspace/rust/yasp)`</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  process didn<span class="string">&#x27;t exit successfully: `/home/you06/workspace/rust/yasp/target/debug/build/yasp-01bf64e1e5e0f353/build-script-build` (exit code: 1)</span></span><br><span class="line"><span class="string">--- stdout</span></span><br><span class="line"><span class="string">processing file `/home/you06/workspace/rust/yasp/src/grammar.lalrpop`</span></span><br><span class="line"><span class="string">/home/you06/workspace/rust/yasp/src/grammar.lalrpop:46:15: 46:30 error: ambiguity detected between the terminal `r#&quot;[0-9a-zA-Z_]+&quot;#` and the terminal `r#&quot;(?i)from&quot;#`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--- stderr</span></span><br><span class="line"><span class="string">  Name: CIStr = r&quot;[0-9a-zA-Z_]+&quot; =&gt; &lt;&gt;.into();</span></span><br></pre></td></tr></table></figure><p>报错的原因是<code>select</code>和<code>from</code>既能够满足我们所期望的<code>Expr</code>的语法，也能够满足<code>Field</code>的语法，所以<code>lalrpop</code>不知道它属于那一个符号。在<code>SQL</code>语言里，是不能够将例如<code>select</code>，<code>from</code>这种关键词作为表名和字段名来使用的。对于固定的字符串，<code>lalrpop</code>会将它置于比正则匹配更高的优先级，所以纯小写的<code>SQL</code>能够被解析，但如果有多个正则表达式，他们之前将无法区分优先级（也无法做优先级标注），这造成了直接解析的失败。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cherry Bot</title>
    <link href="http://yoursite.com/2020/04/23/cherry-bot/"/>
    <id>http://yoursite.com/2020/04/23/cherry-bot/</id>
    <published>2020-04-23T19:12:29.516Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://user-images.githubusercontent.com/9587680/60788142-95abc100-a18e-11e9-9a42-fbf21a023449.jpg" alt="bot logo"></p><h2 id="How-I-cames-from"><a href="#How-I-cames-from" class="headerlink" title="How I cames from"></a>How I cames from</h2><p>I will talk about this bot from my story. Things began from was July 2019, I joined PingCAP as an intern. Holy I was a noob of golang and knew nothing about rust that time. The best way learning a language is by practising, I started my first golang project named cherry-picker. As the name shows, this is a tool which helps PingCAP’s engineers cherry pick PRs from master branch to release branch. The project soon ran out of my expectation, we started in TiDB, then expanded to TiKV and PD. I noticed that this bot is such awesome, in the following months, the bot growed quickly, some features were deprecated and some were optimized. Nowadays, the bot is widely used in PingCAP, and we think it’s time to share the bot with you!</p><a id="more"></a><h2 id="About-my-name"><a href="#About-my-name" class="headerlink" title="About my name"></a>About my name</h2><p>For a long time, I name the bot “cherry-picker”, because it’s the first feature of the bot. This time, I give it a new name, “Cherry Bot”, so the logo of bot will not change lol! By now, there are over 10 providers in this bot 🍻.</p><h2 id="The-mostly-used-features"><a href="#The-mostly-used-features" class="headerlink" title="The mostly used features"></a>The mostly used features</h2><h3 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry Pick"></a>Cherry Pick</h3><p>Bug fix pull requests in repositories with multi branches like <code>release-xx</code> and <code>master</code> are usually required to be cherry picked to release branches, manually do this would be tedious. It would be worse if we forget cherry picking bug-fix pull requests. Then the bot comes, it cherry picks every merged PR with specific labels, like pull request labeled with <code>needs-cherry-pick-2.0</code> will be cherry picked to <code>release-2.0</code> branch. What about conflicts? The conflicts are common between branches, the bot can be configured to generate conflicted pull requests either report a conflict failure. The conflict pull requests would be like the following which can be specified by IDEs.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">branch contents</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">bug fix contents</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1234567890abcdef</span><br></pre></td></tr></table></figure><h3 id="Auto-Merge"><a href="#Auto-Merge" class="headerlink" title="Auto Merge"></a>Auto Merge</h3><p>If you are using some languages which have a heavy cost in compile or there are some tests that would last for a long time. After the reviewing of the pull request is finished, the CI may still running. Sometimes we would require the pull request tested with up to date changes. GitHub offers <code>Update Branch</code> to merge the latest changes from base branch, but after this action, the CI should be restarted. Think about this, a pull request is ready to merge and waiting for CI finished, then the base branch is updated, which makes a force update of this pull request and the CI restarts. A thousands years later, the CI is finally about to success, a pull request merged into the base branch again which makes the CI should restarted again. The same thing may be caused by you AFK while waiting for CI done. This makes pull requests under the state of competition, and the most of the CI’s job would be waste. The bot offer a mechanism to merge pull requests in a queue. When maitainers commented with <code>/merge</code>, the bot will labeled the pull request with <code>status/can merge</code> which stands for the pull request will be auto merged. If the pull request need to be waited for others, bot will comment with all the waited pull request numbers. This auto merge job can be canceled by remove the <code>status/can merge</code> label easily.</p><h3 id="Redeliver-Command"><a href="#Redeliver-Command" class="headerlink" title="Redeliver Command"></a>Redeliver Command</h3><p>PingCAP uses Jenkins for CI trigger and scheduler, some commands in Jenkins are only available for organization members. Besides, we also want some commands can be used by pull request owner, that’s why redeliver command comes. Comment with <code>@bot /run-integration-test</code>, then the bot will trigger this for you by comment with <code>/run-integration-test</code>. Do not try call <code>@bot /merge</code>, this would never work 😕.</p><h3 id="Auto-Update"><a href="#Auto-Update" class="headerlink" title="Auto Update"></a>Auto Update</h3><p>Some large project will have multiple repos. For example <code>TiKV</code> have the dependency <code>rust-rocksdb</code> and <code>rust-rocksdb</code> is based on <code>RocksDB</code> and <code>Titan</code>. This means any updates from <code>RocksDB</code> or <code>Titan</code> will need to be updated to <code>rust-rocksdb</code> then <code>TiKV</code>. We are always not to do this manually, that’s the bot’s time, give me the chore. The bot will auto file up a pull request to update the sub modules.</p><h3 id="More-Providers"><a href="#More-Providers" class="headerlink" title="More Providers"></a>More Providers</h3><p>There are still many providers I’ve not mentioned in this blog, check it out if you’re interested <a href="https://github.com/pingcap-incubator/cherry-bot/tree/master/pkg/providers">https://github.com/pingcap-incubator/cherry-bot/tree/master/pkg/providers</a>. For those features added into bot, I try to make them common instead of dedicated. And I’m expecting to get some feedbacks from community users.</p><h2 id="About-the-Code"><a href="#About-the-Code" class="headerlink" title="About the Code"></a>About the Code</h2><p>When I code this bot, I’m new to Golang. There are some unnacessary interfaces, redundant expressions and unsatisfied error handlings. I’ve made some efforts to make clean up the code, but it’s so so so a big work, it’s just like code the bot again 😭.</p><h2 id="Grumbles"><a href="#Grumbles" class="headerlink" title="Grumbles"></a>Grumbles</h2><p>I’ve written a lot of Golang code in the past year. This language is like a quad bike which makes everyone easy to drive. When use Golang in some projects, I often code many high repeatable expressions, like <code>if err != nil</code> which makes me feel pain. Also the feeling of controlling everything in CPP is missing. It’s not smart in both grammar and extreme performance. However, it’s still a preferred language for building some apps, where the performance is good enough and you don’t need to worry about whether memory is in stack or heap(I’m not sure whether it’s an advantage). Anyway, longtime writing Golang is tired, more features are always wanted like iterator, general types etc. The last complain, when doing some worthless jobs for fun, I’m very willing to try languages with more complexity. A further thinking, will you like a language which brings the ability of low level programming without knowledge of computer system?</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/9587680/60788142-95abc100-a18e-11e9-9a42-fbf21a023449.jpg&quot; alt=&quot;bot logo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;How-I-cames-from&quot;&gt;&lt;a href=&quot;#How-I-cames-from&quot; class=&quot;headerlink&quot; title=&quot;How I cames from&quot;&gt;&lt;/a&gt;How I cames from&lt;/h2&gt;&lt;p&gt;I will talk about this bot from my story. Things began from was July 2019, I joined PingCAP as an intern. Holy I was a noob of golang and knew nothing about rust that time. The best way learning a language is by practising, I started my first golang project named cherry-picker. As the name shows, this is a tool which helps PingCAP’s engineers cherry pick PRs from master branch to release branch. The project soon ran out of my expectation, we started in TiDB, then expanded to TiKV and PD. I noticed that this bot is such awesome, in the following months, the bot growed quickly, some features were deprecated and some were optimized. Nowadays, the bot is widely used in PingCAP, and we think it’s time to share the bot with you!&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术杂谈" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    <category term="English" scheme="http://yoursite.com/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>关于公众人物与普通人关系的想法</title>
    <link href="http://yoursite.com/2020/03/03/public-figure/"/>
    <id>http://yoursite.com/2020/03/03/public-figure/</id>
    <published>2020-03-03T19:45:17.715Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>「认真写完一条回复之后发现对方说做不到与回复交流这件事，于是为了不打扰又删掉了写完的内容，要传达到自己的意思好难啊。」</p><p>发完这条动态后，我跑去对方的个人主页，发现对方也是一样的不接受几乎所有的交流和评论。本身是我相当喜欢的一个创作者，所以有些受到打击的感觉，于是花了些时间来充值自己的信仰。在这过程中就想到了一些乱七八糟的东西，而我也仅敢将其称作「想法」，不敢提拔到「思考」的高度。</p><h2 id="公众人物"><a href="#公众人物" class="headerlink" title="公众人物"></a>公众人物</h2><p>首先谈一下我眼中的「公众人物」这个词，我对其没有什么特殊的研究，Wikipedia 的解释是「指具有一定社会地位、並在社会具有影响力与曝光度的人士」，当然我不能全部接受这个解释，需要补充一些细节。</p><ul><li>公众人物不一定需要具有社会地位</li><li>公众人物的一个必要条件是接触/被接触的人群是不确定的多数人</li><li>上一条中的「接触」并不能只是因为工作原因，比如服务业接触客户就不符合这个条件</li></ul><p>公众人物有着影响力与被影响力的特点，影响力很容易理解，指的是他说的话能够被很多人所听到；而被影响力指的是他能听到与他毫无关系的人所说的话，比如发了一条推，下面会出现以前从未见到过的人的评论。</p><p>公众人物范围广泛，而有的分类我既不了解，也不适合说，一下从几个方面说一说这一群体的局部特征。</p><p>⚠️：<strong>以下内容含有胡说八道，扭曲黑白等元素，拒绝观看自己所不认同的观点的话建议关掉这篇博客，我怕被喷</strong></p><h3 id="偶像"><a href="#偶像" class="headerlink" title="偶像"></a>偶像</h3><p>「偶像」是「公众人物」的毕业形态之一，是发展到最终阶段的成熟的、稳定的一个群体，并且与他的观众之间已经建立了稳定的关系。最近关于「观众」的话题很火，我不懂这其中的奥妙所以不拱火。我们来说稳定，这一稳定的概念在不同文化和观众下有着不同的体现和制约，比如偶像恋爱、结婚了，就会打破一些观众眼中的平衡。但是偶像能红五年以上的例子非常之多，所以我说这是一种稳定的毕业形态。至于其特点，我也不是非常有研究，但不妨瞎说一顿：</p><ul><li>偶像与观众之间的关系由代理人维护，所以极少能见到偶像会与观众直接互动的</li><li>偶像的形象被包装，观众所看到的人格并不一定是真实的</li></ul><p>以上两点，并非缺点，他是稳定的重要因素，理由大家应该都懂。</p><h3 id="网红"><a href="#网红" class="headerlink" title="网红"></a>网红</h3><p>与「偶像」不同，「网红」就没有那么稳定，我翻了翻脑袋，发现想不出几个五年前就红起来的网红（有可能是网红的出现较晚的原因）。与偶像不同，网红和观众的接触要更多更直接，比如职业主播，几乎每天都会面向观众说上好几个小时，在这种环境下，原本的形象变得更加容易传达到观众眼里，而包装，也就变得更加困难。直播必备弹幕，一个网红直播，也一定要和弹幕互动，在这其中，也就没有了代理人插足的空间。</p><h3 id="创作者"><a href="#创作者" class="headerlink" title="创作者"></a>创作者</h3><p>好了终于到了我真的想要说的事，前言所展示的动态，就是我和一个创作者之间发生的事情，虽然对方毫无感觉，但我的确是受到了不小的影响。和前两个群体不同的是，这一个群体更多的吸引人的地方，在于其作品产出，并非人格本身，他可能相貌平平，可能生活习惯恶劣，可能拖稿严重，但是只要作品赢得了观众的青睐，他和观众之间的桥梁就建立起来了。我把创作者与观众之间的关系同样划分位「公众人物」的稳定的毕业形态之一，附加的一点是，创作者同样可以选择不成为「公众人物」。</p><p>在发了前言的动态之后，我进入了那位创作者的个人主页，个人介绍里写着不接受约稿、转发等规则。当然这不是什么大问题，创作者不需要维护一个人见人爱的个人形象，所以可以尽情的发挥自己任性的想法。然而我当时是比较震惊的，为了让自己接受这一点并且继续喜欢对方的作品，花了很长的时间以及写了这篇博客来调整自己的心态。</p><p>首先说一下我个人的吐槽，评论了却得不到回复是很正常的事，但是得到回复却是非常开心的事，能够理解不想与人交流的心态，但也会为此感到伤心。个人介绍里完全可以写一些更加有趣的东西，为什么要直接将我推开呢？前面这个观点是很自私的，因为我不知道对方的实情。</p><p>其实此前我也看到过对方在推上说自己害怕社交，所以上述个人吐槽其实非常失礼，但这也的确是我本人的心态变化，所以记录下来。</p><p>观众会想象公众人物是他们心目中的样子，作为创作者也不例外会时常的受到这种期待，但这是不合理的，只是因为他们的工作成果被大家所享受，就对其提出公众人物的要求的话，是自身欲望的过度扩张。所谓创作者，只不过是全心全力的创作自己的作品而已，他们甚至都可以不将其发表，为什么一定要背负「公众人物」的期待呢？</p><p>想通了这些事情之后，我订阅了对方的 pixiv fanbox~ Good night 🌙</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
    <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>评「G線上の魔王」</title>
    <link href="http://yoursite.com/2020/03/01/g-string/"/>
    <id>http://yoursite.com/2020/03/01/g-string/</id>
    <published>2020-03-01T07:00:03.310Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>G弦上的魔王初次玩是在很早的时候了，最近白开水游戏玩得多，经常会想起这部作品，于是就把这游戏全部通了。这不是一篇游戏鉴赏，只是个人对于游戏的一些看法。</p><a id="more"></a><p>有人说这部作品日常部分稍微有所欠缺，可能是最近玩多了没什么剧情的作品，对这点我并没有太多的感觉到，G弦的剧情没有任何时候使我感到不耐烦。</p><p>下文按照游戏的剧情顺序展开。<br>下文将涉及到剧透情节。</p><p>椿姬线玩下来我其实是没有多大的回味的，这条线对主角的塑造比女主要好的多，站在和魔王、权三一致的立场上，宫介如何对自己的行为做出选择。一方面是违背权三的命令，可能有性命的危险，另一方面是亲手破坏椿姬的家庭，这一段的描述非常精彩，对椿姬坦白自己的立场，最后做出选择，要挟权三，虽然结局处有些矛盾没有处理的特别好，但对于男主的性格描述可以说是不错了。这条线中对椿姬的描述我没有太多的感想，比较普通，这个角色的性质过于单纯。</p><p>花音线是我很喜欢的一条线，主角身上不再存在激烈的冲突，故事的看点在花音身上，令我最满足的一点是，在这条线中，花音是个活生生的人。上一条线的椿姬，在通关之后我甚至以为这条线是为男主的角色刻画而设置的。与其他线相比，花音线的剧情比较没有太多脱离实际的地方，魔王在这一章的表现也没有那么亮眼，表面上是魔王暗杀花音身边的人，实际倒不如说是花音自身内心的斗争。</p><p>我很喜欢像花音这种将所有的精力投入到自己所专注的事情当中去，对其他事几乎不闻不问的性格。她能在自身的领域登峰造极，但又对这之外的事比较脱线，有时候干脆是闭上眼睛，眼不见心不烦。对处于这种状态下的花音，游戏在花音线的初期初期使用了女武神的背景音乐，完美的胜利。人心是脆弱的，面对同样有病态心理的母亲，花音并不能让自己一直处于对任何事情都不闻不问的状态，在媒体面前失控，比赛出现重大失误。结局是好结局，比起椿姬，花音像是一个正常人的表现。后内点冰四周跳，当花音成功做出这个动作时，我甚至在电脑前拍手叫好，所有前置的压力在这一幕都变成了花音的表演。在前往自由滑赛场之前，那首漫步所改编的悟り，去除了所有紧张的气氛。</p><p>水羽我认为是一个很好的人设，事实上也有老哥单推水羽。相比于游戏整体较为紧张的气氛，水羽线的展开就像插播的恋爱喜剧一样，游戏过程非常轻松。水羽线与整体剧情并不是那么接轨，可以说是魔王戏份很少的一条线了，从这一点上来看，进入春线的水羽章节对剧情的把握更好。</p><p>直到进入春线，游戏才揭露了魔王的真实身份，矛盾也随之浮上水面，而游戏的标题，G線上の魔王，也有了相应的解释。G弦是小提琴上音色最低沉的一根弦，魔王在春心中留下的阴影使春无法再演奏小提琴。G弦上的咏叹调这首音乐贯穿了整个游戏，越是接近春线，越能感受到春和京介的羁绊，回想起在椿姬线，春对京介说了：要幸福，从此销声匿迹，感到胃痛。进入到恭平带领恐怖分子占领中心街要挟政府的剧情后，游戏剧情变得更加脱离现实，但是不管那部分的剧情处理的如何，对人物的塑造都算成功，魔王滴水不漏的计划令人感慨。</p><p>几个月过去了，我决定为此文写下最后一段作为整体评价，G弦卖的一个大关子（魔王不是主角的另一个人格），实际上我回想起来感到有违和，但我认为小瑕疵不会影响作品的整体质量。当初刚打完的时候因为好久没打这么有味道的作品了，所以给了 10 分，现在再打分的话可能会在 9-9.5 之间吧。另外本作的音乐全部改编自古典，对上胃口的话决定是不容错过的作品。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;G弦上的魔王初次玩是在很早的时候了，最近白开水游戏玩得多，经常会想起这部作品，于是就把这游戏全部通了。这不是一篇游戏鉴赏，只是个人对于游戏的一些看法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>2020 年游戏清单</title>
    <link href="http://yoursite.com/2020/02/23/gamelist-2020/"/>
    <id>http://yoursite.com/2020/02/23/gamelist-2020/</id>
    <published>2020-02-23T17:39:36.393Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2020にゲームリスト</p><p>Gamelist in 2020</p><h2 id="我玩过的游戏"><a href="#我玩过的游戏" class="headerlink" title="我玩过的游戏"></a>我玩过的游戏</h2><p>プレイしたゲーム</p><p>Games I’ve played</p><ul><li><p>サクラノ詩 －櫻の森の上を舞う－</p></li><li><p>ポケットモンスター ソード</p></li><li><p>十三機兵防衛圏</p></li></ul><h2 id="我在玩的游戏"><a href="#我在玩的游戏" class="headerlink" title="我在玩的游戏"></a>我在玩的游戏</h2><p>プレイしているゲーム</p><p>Games I am playing</p><ul><li><p>CROSS†CHANNEL</p></li><li><p>Celeste</p></li></ul><h2 id="我想要玩的游戏（排名分先后）"><a href="#我想要玩的游戏（排名分先后）" class="headerlink" title="我想要玩的游戏（排名分先后）"></a>我想要玩的游戏（排名分先后）</h2><p>プレイしたいゲーム（順位順）</p><p>Games I want to playing (ranked in order)</p><ul><li><p>サクラノ刻　-櫻の森の下を歩む-</p></li><li><p>Ever17 -the out of infinity-</p></li><li><p>eden*</p></li><li><p>うたわれるもの 偽りの仮面</p></li><li><p>うたわれるもの 二人の白皇</p></li><li><p>装甲悪鬼村正</p></li><li><p>ef - the first tale.</p></li><li><p>ef - the latter tale.</p></li><li><p>シンフォニック=レイン</p></li><li><p>君と彼女と彼女の恋。</p></li><li><p>Rewrite</p></li><li><p>この世の果てで恋を唄う少女YU-NO</p></li><li><p>CHAOS;HEAD</p></li><li><p>CHAOS;CHILD</p></li><li><p>ランス10</p></li><li><p>CLANNAD</p></li><li><p>Fate/stay night</p></li><li><p>Xenoblade2</p></li><li><p>ATRI -My Dear Moments-</p></li><li><p>PERSONA5 SCRAMBLE The Phantom Strikers</p></li><li><p>PERSONA5 THE ROYAL</p></li><li><p>FINAL FANTASY VII REMAKE</p></li><li><p>キャサリン・フルボディ</p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
    <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Chaos Mesh Start Note</title>
    <link href="http://yoursite.com/2020/02/23/chaos-mesh-start-note/"/>
    <id>http://yoursite.com/2020/02/23/chaos-mesh-start-note/</id>
    <published>2020-02-23T16:44:10.068Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>この<a href="https://blog.tongmu.me/blog/chaos-mesh-start">ブログ</a>を改善してくれた<a href="https://twitter.com/SSSSSSSHHHHHH4">genboku</a>さんに感謝しました。</p><a id="more"></a><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><ul><li>…に対して…を行こうことできます。</li></ul><p>「対して」は2つの単語を接続できます。</p><ul><li>…に準じた…です。</li></ul><p>「準じた」は基づいてを意味します、「クラウドネイティブに準じた」は”cloud native based”を意味です。<br>例：クラウドネイティブに準じたプレイヤー</p><ul><li>…を行って来ました</li></ul><p>何かした、過去形。</p><ul><li>その結果生まれたの…</li></ul><p>何か行ってきました、その結果は…</p><ul><li>…は…ために行きます。</li></ul><p>行っての目的はなに。</p><ul><li>…より…なるほど、…なります。</li></ul><p>もと…、そしてもと…の意味します。</p><ul><li>…であったとしても…まだあるでしょう。</li></ul><p>何か行ってきました、でも何かまだ起こった。</p><ul><li>さらに…</li></ul><p>もと…</p><p>例：バグはさらに見つけにくくなります。</p><ul><li>…あたり…</li></ul><p>確率のエクスプレス</p><p>例：1時間あたり0.0001％</p><ul><li>…してようやく、…</li></ul><p>何か起こった、そして結果は</p><ul><li>…ことはいうまでもありません</li></ul><p>何がもちろん。</p><ul><li>…に至った理由</li></ul><p>その理由は。</p><ul><li>その中で…</li></ul><p>コネクティブ。</p><ul><li>…しながら、さらに同時に…</li></ul><p>二つのことを同時に行う</p><ul><li>するたびに</li></ul><p>毎回</p><ul><li>さらに上記の問題に共通する事項として、</li></ul><p>まとめの意味。</p><ul><li>…動かしてみましょう。</li></ul><p>始めましたの意味。</p><ul><li>…を1分ごとにランダムに一つ…させます。</li></ul><p>毎分一つの…は…させます。</p><h2 id="使用習慣"><a href="#使用習慣" class="headerlink" title="使用習慣"></a>使用習慣</h2><ul><li>基本を理解する =&gt; 基礎知識</li></ul><p>なにが違い分かりません。</p><ul><li>その故障を対応ために =&gt; その故障＝故障を対応するために</li></ul><p>「＝」は注釈を意味します。</p><ul><li><p>コードモジュール =&gt; コードのモジュール</p></li><li><p>安定性の保障 =&gt; 安定性を保障する</p></li><li><p>…通常は =&gt; 通常の…は（…よりも）</p></li><li><p>可能性が高い =&gt; 可能性がでてきます</p></li><li><p>複数の方法 =&gt; 方法はたくさんあります</p></li><li><p>時間調整する =&gt; 時間を調整したり</p></li><li><p>…します =&gt; …行ったり</p></li><li><p>初に、 =&gt; 最初は、</p></li><li><p>展開する、そして、… =&gt; デプロイし、…</p></li><li><p>…を…の…に失敗した =&gt; …を使用した…の…に失敗したり</p></li><li><p>失敗した =&gt; 失敗する</p></li><li><p>引き起こす =&gt; 引き起こします</p></li><li><p>他の問題 =&gt; 他にも様々な問題</p></li><li><p>使用率は低い =&gt; 使用率が低い</p></li><li><p>…します（目的の意味） =&gt; …する必要がありました</p></li><li><p>同時テスト実行出来る、… =&gt; 同時にテストできましたが、…</p></li><li><p>構成必要 =&gt; 構成する必要</p></li><li><p>スーツ =&gt; スイート</p></li></ul><p>スーツはただ洋服</p><ul><li><p>電源を切る =&gt; 電源切断</p></li><li><p>使用する、… =&gt; 使用している場合は…</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;この&lt;a href=&quot;https://blog.tongmu.me/blog/chaos-mesh-start&quot;&gt;ブログ&lt;/a&gt;を改善してくれた&lt;a href=&quot;https://twitter.com/SSSSSSSHHHHHH4&quot;&gt;genboku&lt;/a&gt;さんに感謝しました。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日语学习" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="日本語" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
  </entry>
  
  <entry>
    <title>Chaos Mesh・Kubernetesのカオス上の舞う</title>
    <link href="http://yoursite.com/2020/02/16/chaos-mesh-start/"/>
    <id>http://yoursite.com/2020/02/16/chaos-mesh-start/</id>
    <published>2020-02-16T12:24:33.279Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>このブログを改善してくれた<a href="https://twitter.com/SSSSSSSHHHHHH4">genboku</a>さんに感謝しました。</p><hr><p><a href="https://github.com/pingcap/chaos-mesh"><code>Chaos Mesh</code></a>はカオスエンジニアリングのためのテストツールです。</p><p>コンテナ化されたアプリケーションに対してカオスなテストを行うことができます。</p><p>そして、クラウドネイティブに準じたオープンソースなツールキットです。</p><a id="more"></a><h2 id="基礎知識"><a href="#基礎知識" class="headerlink" title="基礎知識"></a>基礎知識</h2><h3 id="カオステストが必要な理由"><a href="#カオステストが必要な理由" class="headerlink" title="カオステストが必要な理由"></a>カオステストが必要な理由</h3><p>カオスはプロダクション環境で頻繁に発生します、マシン障害、ネットワーク障害など。それらの障害=故障に対応するために、多くの試行錯誤を行って来ました。その結果生まれたのがカオステストです。</p><p>単体テストはソースコードのモジュールごとの安定性を保障するために行います。同様にカオステストは 故障時の障害対応を安定して行えることを保証するために 行います。</p><p><a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%83%95%E3%82%A3%E3%83%BC%E3%81%AE%E6%B3%95%E5%89%87">マーフィーの法則</a>によれば、<strong>「失敗する余地があるなら、失敗します」</strong>。</p><p>システムがより複雑でより規模が大きくなるほど、潜在的なバグも多くなります。プロダクション運用環境と同じサイズの開発環境であったとしてもバグを見逃すことはまだあるでしょう。しかし、コストを節約するために、通常の開発環境は(プロダクション運用環境よりも)小さいです。バグはさらに見つけにくくなります。</p><p>例えばハードドライブが損傷する確率は1時間あたり0.0001％であると仮定しましょう。100台のハードドライブのクラスターが10,000時間実行してようやく1台のハードディスクが破損する可能性がでてきます。しかし、開発環境ではその可能性は非常に低いことはいうまでもありません。</p><p>カオステストはこの障害状況をシミュレートすることです。</p><h3 id="クラウドネイティブな理由"><a href="#クラウドネイティブな理由" class="headerlink" title="クラウドネイティブな理由"></a>クラウドネイティブな理由</h3><h4 id="クラウドネイティブに至った理由"><a href="#クラウドネイティブに至った理由" class="headerlink" title="クラウドネイティブに至った理由"></a>クラウドネイティブに至った理由</h4><p>カオスの実装方法はたくさんあります。時間のカオスをシミュレートするためにシステム時間を調整したり、ネットワークのカオスをシミュレートするために<code>iptables</code>を使用したファイアウォールのセットアップを行ったり…その中で自分の経験からクラウドネイティブを選んだ理由を説明します。</p><p><code>PingCAP</code>では、非常に早い段階でカオステストを開始しました。</p><p>最初は、<code>SSH</code>経由でマシンにカオスを設定していました。</p><p><img src="https://user-images.githubusercontent.com/9587680/74592246-59144200-505a-11ea-8dd5-e6fd9b561e7a.png" alt="sshで構成されたカオス"></p><p>あの時、僕は<code>TiDB</code>用のカオステストツールを作成しました。</p><p><a href="github.com/pingcap/tidb-ansible/"><code>tidb-ansible</code></a> を使用してTiDBをデプロイし、データベースに接続するロードプログラムを実行しながら、さらに同時にカオス操作を実行するツールです。</p><p>大事な問題は、このテストフレームワークにもバグがあることでした。例えば、<code>tidb-ansible</code>を使用した<code>TiDB</code>のデプロイに失敗したり、<code>iptables</code>のルール削除に失敗するなど（そしてそれは次のテストの環境汚染を引き起こします）。</p><p>他にも様々な問題がありました：</p><ul><li>リソース使用率が低い</li><li>問題が発生した場合、プログラムの実行状態を記述するために、次のテストは停止する必要がありました</li><li>ログ収集を行う必要がありました</li><li>複数のクラスターを同時にテストできましたが、新しいクラスタを追加するたびに、テスト環境を手動で構成する必要がありました</li><li>…</li></ul><p>さらに上記の問題に共通する事項として、このテストスイートを使用するためには、多くの場合、手動による介入が必要でした。</p><h4 id="クラウドネイティブのアドバンテージ"><a href="#クラウドネイティブのアドバンテージ" class="headerlink" title="クラウドネイティブのアドバンテージ"></a>クラウドネイティブのアドバンテージ</h4><ul><li><code>Kubernetes</code>はリソースを適切に管理し、テストに標準環境を提供します</li><li><a href="github.com/pingcap/tidb-operator/"><code>TiDB Operator</code></a>は、<code>TiDB</code>クラスタを管理できます</li><li><code>Chaos Mesh</code>、<code>TiDB Operator</code>などのユニットに分割できます</li></ul><h4 id="クラウドネイティブの欠陥"><a href="#クラウドネイティブの欠陥" class="headerlink" title="クラウドネイティブの欠陥"></a>クラウドネイティブの欠陥</h4><ul><li>ある一部の障害のシミュレートできません。例えば、<strong>電源切断</strong>など。</li></ul><h3 id="Chaos-Meshを試す"><a href="#Chaos-Meshを試す" class="headerlink" title="Chaos Meshを試す"></a><code>Chaos Mesh</code>を試す</h3><p>カオスエンジニアリングによるテストがなぜ必要か。</p><p>そしてChaos Meshがどうしてクラウドネイティブな作りをしているのか。</p><p>わかったところで公式ドキュメント：<a href="https://github.com/pingcap/chaos-mesh#deploy-chaos-mesh">https://github.com/pingcap/chaos-mesh#deploy-chaos-mesh</a>にしたがって、実際に<code>Kubernetes</code>で<code>Chaos Mesh</code>を動かしてみましょう。</p><h4 id="Helm使用して、Chaos-Mesh展開"><a href="#Helm使用して、Chaos-Mesh展開" class="headerlink" title="Helm使用して、Chaos Mesh展開"></a><code>Helm</code>使用して、<code>Chaos Mesh</code>展開</h4><p><code>Helm</code>チャートを取得する</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pingcap/chaos-mesh.git</span><br><span class="line"><span class="built_in">cd</span> chaos-mesh/</span><br></pre></td></tr></table></figure><p>カスタムリソースをインストールする</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f manifests/</span><br><span class="line"><span class="comment"># CRD を確認する</span></span><br><span class="line">kubectl get crd podchaos.pingcap.com</span><br><span class="line">kubectl get crd networkchaos.pingcap.com</span><br><span class="line">kubectl get crd iochaos.pingcap.com</span><br><span class="line">kubectl get crd timechaos.pingcap.com</span><br></pre></td></tr></table></figure><p>通常、コンテナランタイムは<code>Docker</code>。もし他のコンテナランタイムを使用している場合はドキュメントを参照してください。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 名前空間を作成する</span></span><br><span class="line">kubectl create ns chaos-testing</span><br><span class="line"><span class="comment"># helm 2.X</span></span><br><span class="line">helm install helm/chaos-mesh --name=chaos-mesh --namespace=chaos-testing</span><br><span class="line"><span class="comment"># helm 3.X</span></span><br><span class="line">helm install chaos-mesh helm/chaos-mesh --namespace=chaos-testing</span><br><span class="line"><span class="comment"># Chaos Mesh pods を確認する</span></span><br><span class="line">kubectl get pods --namespace chaos-testing -l app.kubernetes.io/instance=chaos-mesh</span><br></pre></td></tr></table></figure><h4 id="テストしてみましょう"><a href="#テストしてみましょう" class="headerlink" title="テストしてみましょう"></a>テストしてみましょう</h4><p>テスト対象のアプリケーションコンテナを実行します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns hello-chaos</span><br><span class="line">kubectl -n hello-chaos create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1</span><br></pre></td></tr></table></figure><p>カオスを設定します。</p><p>例：<a href="https://github.com/pingcap/chaos-mesh/blob/master/examples/pod-kill-example.yaml">https://github.com/pingcap/chaos-mesh/blob/master/examples/pod-kill-example.yaml</a></p><p>hello-chaosネームスペースの<code>app=kubernetes-bootcamp</code>というラベルがついたpodを1分ごとにランダムに一つ終了させます。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">pingcap.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-pod-kill</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">chaos-testing</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">pod-kill</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello-chaos</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">&quot;app&quot;:</span> <span class="string">&quot;kubernetes-bootcamp&quot;</span></span><br><span class="line">  <span class="attr">scheduler:</span></span><br><span class="line">    <span class="attr">cron:</span> <span class="string">&quot;@every 1m&quot;</span></span><br></pre></td></tr></table></figure><p><code>pod kill</code>を適用して、動作しているか確認します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod kill を適用する</span></span><br><span class="line">kubectl apply -f hello-pod-kill.yaml</span><br><span class="line"><span class="comment"># pod 再起動を確認する</span></span><br><span class="line">watch -n 1 kubectl -n hello-chaos get pods</span><br></pre></td></tr></table></figure><h2 id="今後の仕事"><a href="#今後の仕事" class="headerlink" title="今後の仕事"></a>今後の仕事</h2><p>現在の<code>Chaos Mesh</code>にはいくつかの欠陥があります。</p><ul><li>カオスの追加は面倒です</li><li>カオスイベントを視覚化できません</li></ul><p>作業効率を向上し、より良い体験を得るために、<code>Chaos Mesh</code>はこれからも将来的に改善し続けます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;このブログを改善してくれた&lt;a href=&quot;https://twitter.com/SSSSSSSHHHHHH4&quot;&gt;genboku&lt;/a&gt;さんに感謝しました。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pingcap/chaos-mesh&quot;&gt;&lt;code&gt;Chaos Mesh&lt;/code&gt;&lt;/a&gt;はカオスエンジニアリングのためのテストツールです。&lt;/p&gt;
&lt;p&gt;コンテナ化されたアプリケーションに対してカオスなテストを行うことができます。&lt;/p&gt;
&lt;p&gt;そして、クラウドネイティブに準じたオープンソースなツールキットです。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术杂谈" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    <category term="日本語" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
  </entry>
  
  <entry>
    <title>区块链是什么?</title>
    <link href="http://yoursite.com/2019/11/02/about-blockchain/"/>
    <id>http://yoursite.com/2019/11/02/about-blockchain/</id>
    <published>2019-11-02T20:59:15.459Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>区块链是什么？自从朋友圈被新华社的那篇文章刷屏以来，我想很多人都有这个问题，为此特地写一下这篇文章。此前，对于这个问题，也起过一些争执，所以此处尽可能用客观通俗些话说一说区块链是什么。</p><a id="more"></a><p>区块链是某某币（如比特币、以太坊）的必要不充分条件，也就是，要发币，一定有一个区块链在背后支撑，同时并不是所有的区块链都要发币的。</p><p>区块链是基于密码学，分布式存储的一种组合技术，也就是说，区块链能做到的，使用这些基础技术也可以做到，但是大家肯定喜欢打包好的，开箱即用的方案。举个例子，你要出去旅游，本来需要自己订机票、酒店，区块链的用途就像是旅行社的全家桶套餐。</p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><p>区块链在密码学上所解决的问题，是一个经典的非对称加密问题，考虑以下这个场景。甲向乙发送了一封商业合作的电子邮件，乙收到邮件后非常满意，给甲回复接受甲的提案，并拒绝了其他所有公司的邀约。就快到了项目开始的日子，乙见甲迟迟没有动作，就跑到甲的办公室询问情况，甲像没听说过这回事一般，说乙所收到的邮件根本就不是他发出的。在这个案例中，乙遭受了项目不得不推迟的损失，问题是，这个情况下是否应该由甲来承担乙的损失，以及如何避免这种损失。解决这个问题的关键就是乙能够知道这封邮件是真实的甲所发送的这件事，并且在确认邮件是甲所发的情况下，拿出证据，让甲无法抵赖。非对称加密所解决的就是这个问题，甲手上持有私钥，并公开对应的公钥，甲在发送邮件的同时使用私钥做一份签名摘要一起发送，如果这份签名摘要能够被公开的公钥所验证，说明这封邮件的签名摘要一定是持有私钥的人所做出的。</p><p>上面所提的安利就是一个非堆成加密的使用场景，但如果我说这个所谓的商业合作，是买卖价值20元的晚餐食材，是不是就有了一种小题大做的感觉？就算菜市场老板突然说“我不卖了”，作为消费者换一家店买菜便是。同时需要指出，非对称加密并不能完全解决合同问题，假如这个合同是乙向甲采购价值一百万元的火龙果，乙在确保邮件是甲寄出合同生效的情况下已经将钱打给甲，甲按其交货了价值一百万的白心火龙果。乙看到仓库里的火龙果满心欢喜，赶紧吃一个验验货，切开以后大失所望，原来乙想要的是红心火龙果，遂向甲抱怨道“都9102年了怎么还有人卖白心火龙果？”，后甲乙产生争执。可以看出来在这个案例中，出现问题的原因在于约定的内容不准确，把问题抽象一下呢，就是这个加密技术保证了被签名内容的是可信的，但也仅仅保证了被签名的那一封邮件的可信度而已。</p><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><p>和非对称加密不同，分布式存储有许多方案，所以这部分不单独谈，会结合在区块链中的应用来谈。设想一下在上面的情境中，假如甲乙达成了买卖一百万红心火龙果的合同，并且双方都留了对方所签名的邮件当作证据。临近交易的日子，丙找到甲，说愿意以一百二十万元的高价购买甲准备卖给乙的红心火龙果，甲利欲熏心，潜入乙的办公室，破坏了乙的电脑。到了甲乙所约定的交易日，乙带着一百万来提货时，甲对合同的事矢口否认，当以想要以邮件为证据将甲告上法庭时，发现自己的电脑坏了，证据已经不复存在。在这个案例中，乙的权利能否得到维护，在于乙有没有在其他存储设备上备份和甲通信的邮件，如果乙掏出一个有备份邮件的移动硬盘，甲就只能乖乖认账。当然手动备份是分布式存储的一种效率很低的方式，现代的分布式存储有不少成熟的方案，此处不予赘述。</p><p>那么区块链是怎么做分布式存储的呢？他要求所有参与交易的人都存有每一个记录，在上面这个案例中，甲向乙所发送的邮件，同样需要经过丙的认同才能够生效，而邮件的内容，在甲乙丙的电脑上都有存档。也许你已经发现了，在上面这个案例中，丙都和甲勾结起来了，又如何站出来为乙作证？如果这封邮件还经过其他几个商人的验证，并且也存在了他们的电脑上，并且他们中有人充满了正义，愿意站出来为乙作证，这时候甲和丙就只能乖乖认账。</p><p>当然，作为一个成熟的商人，乙在这件事情上不能完全指望别人，他完全可以将所有和甲通信的邮件存储在秘书、会计、财务的电脑上都存储一份，狡兔三窟，任凭甲怎么搞破坏，也别想赖账。</p><p>此时有了两个方案，一是将所有邮件存储在一个商会的所有成员的电脑上，二是自己负责数据的可靠性。此处若再深入对比，就难免要涉及到比较技术性的话题，所以简单的说一些符合直觉的结论。第一种方案，有一个特点就是甲乙通讯的每一封邮件都要经过商会里的所有人确认，就像是老师每说一句话，都得问一下“同学们，听清楚了吗？”，于是交流就变得非常低效了，这就是所谓的昂贵的“信任的代价”，而第二种方案，就得根据自己对数据可靠性的要求程度来做分布式存储，此处不再讨论。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>至此我们花了如此大的篇幅来讲述<code>密码学</code>和<code>分布式存储</code>这两个东西，那么区块链是什么？其实在分布式存储的例子中，我已经把密码学的应用代入进来了，上文所说的方案一，就是区块链所选择的方案，至于再深入评价，免不了显得立场过于激烈，又怕得罪读者的一些立场，所以剩下的评价就交给读者自己去思考了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;区块链是什么？自从朋友圈被新华社的那篇文章刷屏以来，我想很多人都有这个问题，为此特地写一下这篇文章。此前，对于这个问题，也起过一些争执，所以此处尽可能用客观通俗些话说一说区块链是什么。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术杂谈" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>TiDB表达式执行过程</title>
    <link href="http://yoursite.com/2019/10/22/tidb-expression-execflow/"/>
    <id>http://yoursite.com/2019/10/22/tidb-expression-execflow/</id>
    <published>2019-10-22T13:48:48.964Z</published>
    <updated>2021-01-26T09:32:50.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TiDB表达式执行过程"><a href="#TiDB表达式执行过程" class="headerlink" title="TiDB表达式执行过程"></a><code>TiDB</code>表达式执行过程</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><code>TiDB</code>向下兼容<code>MySQL</code>，但同时也支持许多<code>MySQL</code>里所没有的表达式，本文将描述表达式被解析和执行的过程。</p><a id="more"></a><h2 id="表达式被解析的过程"><a href="#表达式被解析的过程" class="headerlink" title="表达式被解析的过程"></a>表达式被解析的过程</h2><p>我们先来看<code>TiDB</code>的源码，<code>server/server.go</code>中为<code>Server</code>定义<code>Run</code>方法里实现了监听连接的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := s.listener.Accept()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span> s.onConn(clientConn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过错误处理之后，这个连接对象被塞给了<code>onConn</code>方法，我们顺藤摸瓜继续看。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onConn runs in its own goroutine, handles queries from this connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">onConn</span><span class="params">(conn *clientConn)</span></span> &#123;</span><br><span class="line">ctx := logutil.WithConnID(context.Background(), conn.connectionID)</span><br><span class="line">...</span><br><span class="line">conn.Run(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一些处理之后，会调用<code>conn.Run</code>方法，继续看看<code>Run</code>方法里面写了些什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run reads client query and writes query result to client in for loop, if there is a panic during query handling,</span></span><br><span class="line"><span class="comment">// it will be recovered and log the panic error.</span></span><br><span class="line"><span class="comment">// This function returns and the connection is closed if there is an IO error or there is a panic.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *clientConn)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line">data, err := cc.readPacket()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> err = cc.dispatch(ctx, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// error handle</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确认过注释，就是我想要的代码，里面所调用的<code>cc.dispatch</code>就是处理单个查询的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatch handles client request based on command which is the first byte of the data.</span></span><br><span class="line"><span class="comment">// It also gets a token from server which is used to limit the concurrently handling clients.</span></span><br><span class="line"><span class="comment">// The most frequently used command is ComQuery.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *clientConn)</span> <span class="title">dispatch</span><span class="params">(ctx context.Context, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">cmd := data[<span class="number">0</span>]</span><br><span class="line">data = data[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> cmd &lt; mysql.ComEnd &#123;</span><br><span class="line">cc.ctx.SetCommandValue(cmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataStr := <span class="keyword">string</span>(hack.String(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> cmd &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> mysql.ComQuery: <span class="comment">// Most frequently used command.</span></span><br><span class="line"><span class="comment">// For issue 1989</span></span><br><span class="line"><span class="comment">// Input payload may end with byte &#x27;\0&#x27;, we didn&#x27;t find related mysql document about it, but mysql</span></span><br><span class="line"><span class="comment">// implementation accept that case. So trim the last &#x27;\0&#x27; here as if the payload an EOF string.</span></span><br><span class="line"><span class="comment">// See http://dev.mysql.com/doc/internals/en/com-query.html</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span> &amp;&amp; data[<span class="built_in">len</span>(data)<span class="number">-1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">data = data[:<span class="built_in">len</span>(data)<span class="number">-1</span>]</span><br><span class="line">dataStr = <span class="keyword">string</span>(hack.String(data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cc.handleQuery(ctx, dataStr)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> mysql.NewErrf(mysql.ErrUnknown, <span class="string">&quot;command %d not supported now&quot;</span>, cmd)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我摘取了一部分 dispatch 的代码，以我们最常用的 query function 为例，接着看<code>handleQuery</code>函数。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *clientConn)</span> <span class="title">handleQuery</span><span class="params">(ctx context.Context, sql <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">rs, err := cc.ctx.Execute(ctx, sql)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cc.ctx</code>是一个<code>QueryCtx</code>接口，找到实现了这个接口的<code>TiDBContext</code>结构体，在<code>server/drive_tidb.go</code>之中，实现的方法代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute implements QueryCtx Execute method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *TiDBContext)</span> <span class="title">Execute</span><span class="params">(ctx context.Context, sql <span class="keyword">string</span>)</span> <span class="params">(rs []ResultSet, err error)</span></span> &#123;</span><br><span class="line">rsList, err := tc.session.Execute(ctx, sql)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>session.Execute</code>的实现在<code>session/session.go</code>之中，从<code>TiDBContext</code>之中调用的 sql 执行命令只是其中的一部分，还有其他 sql 调用也会在这里执行这里处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> session <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">parser *parser.Parser</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *session)</span> <span class="title">Execute</span><span class="params">(ctx context.Context, sql <span class="keyword">string</span>)</span> <span class="params">(recordSets []sqlexec.RecordSet, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">charsetInfo, collation := s.sessionVars.GetCharsetInfo()</span><br><span class="line"><span class="keyword">if</span> recordSets, err = s.execute(ctx, sql); err != <span class="literal">nil</span> &#123;</span><br><span class="line">s.sessionVars.StmtCtx.AppendError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *session)</span> <span class="title">execute</span><span class="params">(ctx context.Context, sql <span class="keyword">string</span>)</span> <span class="params">(recordSets []sqlexec.RecordSet, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">stmtNodes, warns, err := s.ParseSQL(ctx, sql, charsetInfo, collation)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *session)</span> <span class="title">ParseSQL</span><span class="params">(ctx context.Context, sql, charset, collation <span class="keyword">string</span>)</span> <span class="params">([]ast.StmtNode, []error, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> span := opentracing.SpanFromContext(ctx); span != <span class="literal">nil</span> &amp;&amp; span.Tracer() != <span class="literal">nil</span> &#123;</span><br><span class="line">span1 := span.Tracer().StartSpan(<span class="string">&quot;session.ParseSQL&quot;</span>, opentracing.ChildOf(span.Context()))</span><br><span class="line"><span class="keyword">defer</span> span1.Finish()</span><br><span class="line">&#125;</span><br><span class="line">s.parser.SetSQLMode(s.sessionVars.SQLMode)</span><br><span class="line">s.parser.EnableWindowFunc(s.sessionVars.EnableWindowFunction)</span><br><span class="line"><span class="keyword">return</span> s.parser.Parse(sql, charset, collation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到<code>session</code>的定义之中，一路追踪表达式被处理的流程，发现他被丢给了<code>parser</code>。</p><p><a href="https://github.com/pingcap/parser"><code>parser</code></a>是一个被独立出来专门用来处理<code>TiDB</code>的表达式的组件。对于<code>parser</code>的逻辑解读将在下一篇博客中描述。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TiDB表达式执行过程&quot;&gt;&lt;a href=&quot;#TiDB表达式执行过程&quot; class=&quot;headerlink&quot; title=&quot;TiDB表达式执行过程&quot;&gt;&lt;/a&gt;&lt;code&gt;TiDB&lt;/code&gt;表达式执行过程&lt;/h1&gt;&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TiDB&lt;/code&gt;向下兼容&lt;code&gt;MySQL&lt;/code&gt;，但同时也支持许多&lt;code&gt;MySQL&lt;/code&gt;里所没有的表达式，本文将描述表达式被解析和执行的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术杂谈" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>关于 TiDB 日文文档</title>
    <link href="http://yoursite.com/2019/10/15/about-tidb-jp-doc/"/>
    <id>http://yoursite.com/2019/10/15/about-tidb-jp-doc/</id>
    <published>2019-10-15T17:58:47.164Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>TiDB</code>日文文档这个坑其实早就有想法了，但原本也没打算这么早开。</p><ul><li><a href="https://you06.github.io/tidb-docs-jp/">doc</a></li><li><a href="https://github.com/you06/tidb-docs-jp">repo</a></li></ul><a id="more"></a><h1 id="关于开坑"><a href="#关于开坑" class="headerlink" title="关于开坑"></a>关于开坑</h1><p>周末的时候在看日语语法，看了之后觉得需要做些题，我一个萌新也不知道做什么好，就跑去问大手子。大手子先是说“我不做题的”，然后给我指了条明路——翻译ben子，据说多翻翻就能过 N1 了。</p><p>好吧我这么正经的人怎么会去翻ben子，然后就想起了这个日文文档的坑，那就开吧。然后当天就用<a href="https://www.gitbook.com/"><code>gitbook</code></a>搞了一份出来，写了个序，摸了。</p><h1 id="文档的一些选择"><a href="#文档的一些选择" class="headerlink" title="文档的一些选择"></a>文档的一些选择</h1><p>但是过了几天之后我就放弃了<code>gitbook</code>，采用了<a href="https://github.com/rust-lang-nursery/mdBook"><code>mdbook</code></a>这个工具来写文档，这里稍作解释。主要原因是我不愿意在这件事情想引入一个第三方平台，和许多静态博客一样，源码放在<code>GitHub</code>，构建后的网站放在<code>GitHub Pages</code>上是最简洁的流程。其二是因为我司的环境比较融入<code>rust</code>生态，所以<code>mdbook</code>作为一个<code>cargo</code>包，个人会比较想要用它。</p><p>构建和文本规范检查用的是<a href="https://github.com/features/actions"><code>GitHub Actions</code></a>，作为<code>GitHub</code>家自产的<code>CI</code>，可以说上手体验是很不错了，如果用第三方<code>CI</code>，部署到<code>gh-pages</code>分支会很头疼，可以参考 <a href="https://github.com/rust-lang/simpleinfra/blob/master/travis-configs/static-websites.yml">rust-lang/simpleinfra</a>里的<code>travis</code>配置。显然我不是一个<code>travis</code>或是<code>CircleCI</code>专家，所以在这种地方就想要尽可能的简单，所以借助<a href="https://github.com/JamesIves/github-pages-deploy-action">github-pages-deploy-action</a>这个工具完成了自动部署的工作。</p><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p><code>TiDB</code>目前开发中的版本是<code>4.0.0-alpha</code>，稳定的版本为<code>release-3.0</code>和<code>release-3.1</code>，<code>release-3.1</code>是从<code>release-3.0</code>切出来的，文档还是使用的 3.0 版本。因此，翻译工作也将从 3.0 开始做起。估计等我 3.0 做的差不多了就该 4.0 发布了，所以 2.0 的文档没有填坑计划。</p><p>这个翻译项目在很长一段时间内会作为个人项目进行，在有一定完成度之后会有进入到官方仓库的意向（反正我现在不好意思提到官方仓库去）。</p><p>当然也希望多多收到 PR，有大手来 review 我的翻译就更好了。</p><h1 id="一些插曲"><a href="#一些插曲" class="headerlink" title="一些插曲"></a>一些插曲</h1><p>做这个翻译的过程中逼着自己写日文，也翻了很多日文技术相关的文档，参考措词。俺日本语本当苦手，然而正如大手所言，的确是个学习的好方式。</p><p>此前这个文档项目我只在微博和推上提到过，然后不知道怎么就被公司的大佬发现了，导致坑还没开（刚写完序，实际还没开始翻），就收获了一些<code>star</code>。并且推还被大佬点了个赞，我推上天天转色图应该没翻车吧？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;TiDB&lt;/code&gt;日文文档这个坑其实早就有想法了，但原本也没打算这么早开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://you06.github.io/tidb-docs-jp/&quot;&gt;doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/you06/tidb-docs-jp&quot;&gt;repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术杂谈" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>关于我和博客</title>
    <link href="http://yoursite.com/2019/10/06/hello-world/"/>
    <id>http://yoursite.com/2019/10/06/hello-world/</id>
    <published>2019-10-06T11:15:00.000Z</published>
    <updated>2021-01-26T09:32:50.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><p>几年前曾经做过一个<a href="https://github.com/you06/maple-blog">个人博客</a>，现在看起来代码比较简陋，所以决定推翻重写。</p><p>新的博客叫 <a href="https://github.com/you06/cosmos-blog">cosmos-blog</a>，是一个使用 <code>nuxt</code> 搭建的博客，选择 <code>nuxt</code> 的原因是能够同时满足以下几点：</p><ul><li>本人对 <code>Vue</code> 比较熟悉，没有学习成本</li><li>服务端能够将 markdown 渲染成 html，我不想让博客源文件能被直接拿到</li><li><code>SSR</code> 的支持</li></ul><p>这个博客也将作为一个长期维护项目，在写的过程中也发现了 <code>nuxt</code> 这个框架以及一些模块的坑，也会借着维护这个博客的机会去尝试为社区做一些贡献。</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>读研中，同时 <code>PingCAP</code> 实习，目前以及之后一段时间内的兴趣范围会在一些 <code>golang</code> 和 <code>rust</code> 开发的范围内做一些研究。</p><p>日语学习中，目标明年7月 N1，<code>TiDB</code> 的日文文档翻译的目的之一就是为了激励自己达成这个目标。</p><p>喜欢游戏，动漫，是二次元。下落式音游，<code>osu! mania</code> 玩的多，<a href="https://osu.ppy.sh/users/4669409">个人页面</a>。柚子八月双厨，最喜欢的公司是枕社。手游目前玩明日方舟和公主连接（台一）。</p><p>有空也会读书，读书兴趣广泛，眼光挑剔，有所感想也会在博客里谈一谈。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>这个博客里写的东西会很多，只要是我想写的，想说的，都可能会在这里发表，包括但不限于：</p><ul><li>作为业余者的网页开发杂谈</li><li><code>TiDB</code>, <code>TiKV</code> 的各种讨论文</li><li><code>TiDB</code> 的日文文档翻译</li><li>动画/游戏的感想</li><li>日记</li><li>读书感想</li></ul><p>除去一些说不得的东西，我认为个人博客是一个想说什么说什么的地方，观点有很强的个人色彩，或许偏激。如果作者的一些愚见让你看的不舒服了，不要因此不开心，如果有想要讨论的东西，也欢迎给我发邮件。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    
  </entry>
  
</feed>
