<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
<link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="icon" type="image/png" href="/icon/icon-196x196.png" sizes="196x196">
<link rel="icon" type="image/png" href="/icon/icon-96x96.png" sizes="96x96">
<meta name="description" content="CRDB 在 SIGMOD 2022 上发表了一篇关于他们如何做 multi-region DB 的论文「Enabling the Next Generation of Multi-Region Applications with CockroachDB」，为这个题目交上了一份相对完整的答案。 Multi-Region 的需求来源于高可用和政策要求（例如 GDPR）。为此，CRDB 引入了一些基础">
<meta property="og:type" content="article">
<meta property="og:title" content="CRDB Global Database">
<meta property="og:url" content="https://blog.tongmu.me/2022/07/31/crdb-global-database/index.html">
<meta property="og:site_name" content="Freezing">
<meta property="og:description" content="CRDB 在 SIGMOD 2022 上发表了一篇关于他们如何做 multi-region DB 的论文「Enabling the Next Generation of Multi-Region Applications with CockroachDB」，为这个题目交上了一份相对完整的答案。 Multi-Region 的需求来源于高可用和政策要求（例如 GDPR）。为此，CRDB 引入了一些基础">
<meta property="og:locale">
<meta property="og:image" content="https://blog.tongmu.me/2022/07/31/crdb-global-database/global-txn-wait.png">
<meta property="article:published_time" content="2022-07-31T18:08:34.000Z">
<meta property="article:modified_time" content="2024-02-14T15:21:24.384Z">
<meta property="article:author" content="you06">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tongmu.me/2022/07/31/crdb-global-database/global-txn-wait.png">
<meta name="twitter:creator" content="@you06v">
<meta name="twitter:title" content="CRDB Global Database">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BCL84R82GK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BCL84R82GK');
</script>


<meta name="twitter:description" content="CRDB 在 SIGMOD 2022 上发表了一篇关于他们如何做 multi-region DB 的论文「Enabling the Next Generation of Multi-Region Applications with CockroachDB」，为这个题目交上了一份相对完整的答案。 Multi-Region 的需求来源于高可用和政策要求（例如 GDPR）。为此，CRDB 引入了一些基础">


<title>CRDB Global Database | Freezing</title>


<link rel="stylesheet" href="/styles/main.css">


    <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Freezing" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="Freezing" type="application/rss+xml">
</head>
    <body>
        <div class="container">
            <header>
<div id='wx_pic' style='margin:0 auto;display:none;'>
    <img src='/icon/wechat-icon.jpg' />
</div>
<div class="main">
<div class="title">
    <a href="/" class="logo">Freezing</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        CRDB Global Database
    </div>
    <p class="sub">Jul 31 2022</p>
    <div class="post-content">
        <p>CRDB 在 SIGMOD 2022 上发表了一篇关于他们如何做 multi-region DB 的论文「Enabling the Next Generation of Multi-Region Applications with CockroachDB」，为这个题目交上了一份相对完整的答案。</p>
<p>Multi-Region 的需求来源于高可用和政策要求（例如 GDPR）。为此，CRDB 引入了一些基础概念：</p>
<ul>
<li>Region，地理上的区域<ul>
<li>Zone，Region 下面的可用区</li>
</ul>
</li>
<li>Table locality，是否为本地表，本地表指主要的访问都来自于一个 region 内</li>
<li>Survivability goal，保持服务可用的情况下能够容忍的错误（zone failure or region failure）</li>
</ul>
<p>这些概念都能够用 SQL 进行表达，并且能够与 DDL 语句无缝结合。同时 CRDB 也有针对不同条件的优化，例如本地表的全局唯一性检测不需要访问远程节点。</p>
<p>这篇文章主要做的工作是：</p>
<ul>
<li>通过将上述三个概念结合到 SQL 中，极大简化 multi-region 的配置</li>
<li>优化器支持 geo-partition</li>
<li>只读事务的 serializability</li>
<li>单 key 事务的 strict serializability</li>
</ul>
<h2 id="抽象与-SQL"><a href="#抽象与-SQL" class="headerlink" title="抽象与 SQL"></a>抽象与 SQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cockroach start \</span><br><span class="line">	--locality=region=us-east-1,zone=us-east-1b <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p>CRDB 在命令行之中指定 region 和 zone，最后整个集群的 region/zone 是所有 node region/zone 的总和，可以通过 <code>SHOW REGIONS</code> 查看。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE movr <span class="keyword">PRIMARY</span> REGION &quot;us-east1&quot; REGIONS &quot;us-west1&quot;, &quot;europe-west1&quot;;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE movr <span class="keyword">ADD</span> REGION &quot;australia-southeast1&quot;;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE movr <span class="keyword">DROP</span> REGION &quot;us-west1&quot;;</span><br></pre></td></tr></table></figure>

<p>CRDB 通过 SQL 执行 database 所属的 region</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE movr SURVIVE REGION FAILURE;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE movr SURVIVE ZONE FAILURE;</span><br></pre></td></tr></table></figure>

<p>通过指定可用性的目标，CRDB 能够更加灵活的调度副本，在可用性目标的容忍范围内，当遇到 region/zone failure 时候，写入请求最多增加一个离最近 region 的 RTT，读请求则不受影响。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> west_coast_users ( ... ) LOCALITY REGIONAL <span class="keyword">BY</span> <span class="keyword">TABLE</span></span><br><span class="line">	<span class="keyword">IN</span> &quot;us-west1&quot;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users ( ... ) LOCALITY REGIONAL <span class="keyword">BY</span> <span class="type">ROW</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> promo_codes <span class="keyword">SET</span> LOCALITY <span class="keyword">GLOBAL</span>;</span><br></pre></td></tr></table></figure>

<p>建表语句能够指定表的 locality，<code>BY TABLE/ROW</code> 的表会优化那一张表/行在指定 region 下的读写性能，<code>GLOBAL</code> 则会优化全局的读性能，牺牲写性能。</p>
<p><strong>自动分区</strong>会 row 放在它被 insert 的分区中，<strong>自动迁移（<code>ON UPDATE rehome_row()</code>）</strong>会将 row 放到它最近被 update 的分区中，为了防止抖动，默认不打开自动分区。</p>
<p>对于那些已经支持分区的应用，他们或许不愿意在 insert 语句中额外指定分区，此时可以使用 <code>REGIONAL BY ROW</code> DDL 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crdb_region crdb_internal_region <span class="keyword">AS</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span></span><br><span class="line">	<span class="keyword">THEN</span> <span class="string">&#x27;us-west1&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;us-east1&#x27;</span> <span class="keyword">END</span>) STORED</span><br></pre></td></tr></table></figure>

<p>对于 <code>REGIONAL BY ROW</code> 的表，可以将 <code>crdb_region</code> 定义为一个计算列，当条件中有 <code>state</code> 时，就会按照这个规则去做 local 查询。</p>
<h2 id="Placement"><a href="#Placement" class="headerlink" title="Placement"></a>Placement</h2><p>CRDB 使用 <a target="_blank" rel="noopener" href="https://www.notion.so/Enabling-the-Next-Generation-of-Multi-Region-Applications-with-CockroachDB-990d2a5971b1480ab89b0715d2bf4326">zone configurations</a> 来配置 placement，CRDB 在 v21.1 支持了 non-voting replicas，也叫 read-only replicas，因此就有了这么一堆看起来很繁琐的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// The difference between num_replicas and num_voters</span><br><span class="line">// determines the number of non-voting replicas.</span><br><span class="line">num_voters = &lt;int&gt;</span><br><span class="line">num_replicas = &lt;int&gt;</span><br><span class="line"></span><br><span class="line">// constraints applies to both voting and non-voting</span><br><span class="line">// replicas. It fixes a replica count per-region,</span><br><span class="line">// allowing the remainder to be placed freely.</span><br><span class="line">// voter_constraints is similar but for voters only.</span><br><span class="line">constraints = &#123;</span><br><span class="line">	+region=&lt;string&gt;: &lt;int&gt;,</span><br><span class="line">	+region=&lt;string&gt;: &lt;int&gt;,</span><br><span class="line">	+region=&lt;string&gt;: &lt;int&gt;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">voter_constraints = &#123;+region=&lt;string&gt;: &lt;int&gt;, ... &#125;</span><br><span class="line"></span><br><span class="line">// lease_preferences pins the leaseholder to a specific</span><br><span class="line">// region, allowing for consistent reads from within.</span><br><span class="line">lease_preferences = [[+region=&lt;string&gt;]]</span><br></pre></td></tr></table></figure>

<p>但是这些繁琐的配置相比于如 “我要求 region failure 时服务不中断” 的口头语还是来的更好用。上一节所说的 locality 配置（<code>REGION BY TABLE/ROW</code> ）就是通过 zone configurations 来实现的。</p>
<ul>
<li>Home region，主要发生读写的 region</li>
<li>Zone survivability，在 zone failure 的 survivability 要求下，3 个 voting replicas 都会被分配在 home region 中（不同的 zone 里），non-home region 里会有 non-voting replicas 来加速读</li>
<li>Region survivability，region survivability 需要容忍 region failure，因此要求至少有 3 个可用 region，在 home region 中有 2 个副本能够成为 candidates，因此 N region 的集群中会有 $𝑚𝑎𝑥 (2 + (𝑁 − 1), 𝑛𝑢𝑚_𝑣𝑜𝑡𝑒𝑟𝑠)$ 个副本</li>
<li>Placement Restricted，最后，因为一些合规的要求（如 GDPR），有些数据不能够出 region，因此 zone survivability 的数据库能够加上 placement restricted 约束，这样所有的 replica 都会确保在 home reigon 内（但是和原本的 zone survivability 有何区别？）。Placement restricted 对 global table 没有效果，并且不能和 region survivability 同时配置</li>
</ul>
<h2 id="考虑-locality-的优化器"><a href="#考虑-locality-的优化器" class="headerlink" title="考虑 locality 的优化器"></a>考虑 locality 的优化器</h2><h3 id="Unique-Constraint"><a href="#Unique-Constraint" class="headerlink" title="Unique Constraint"></a>Unique Constraint</h3><p>CRDB 的 <code>REGIONAL BY ROW</code> 表能够不使用显示的分区 column（也没有用隐藏列），为了保证全局的唯一性，CRDB 为每个 insert/update 语句并行的在每个分区做唯一性检测，这里有 corss-region latency，而为了尽可能降低这种请求带来的延迟，CRDB 在某些情况下会跳过唯一性检测（默认新数据也是唯一的）：</p>
<ul>
<li>UUID 列，因为碰撞率非常低，默认不检查</li>
<li>索引定义上有 <code>crdb_region</code> 标记，如 <code>UNIQUE (crdb_region, col)</code></li>
<li>将 crdb_region 定义为一个 unique column 的生成列，此时 partition 的唯一性能够推断 global 的唯一性</li>
</ul>
<h3 id="Locality-Optimized-Search-LOS"><a href="#Locality-Optimized-Search-LOS" class="headerlink" title="Locality Optimized Search (LOS)"></a>Locality Optimized Search (LOS)</h3><p>当使用一个唯一索引作为查询条件时，至多能找到一条数据，CRDB 会先在本地查询数据是否存在，只有当本地不存在时，才去其他 partition 查找。将这个思路扩展，任何返回有限行的查询（例如 limit 和 where in）都能够优先做本地查找，再做远程查找。同理，在 join 中，根据左表查询右表的值时，也能够使用 LOS 优化。（个人意见，LOS 是一种乐观策略，应该在某些情况下有回退）</p>
<h2 id="Stale-Read"><a href="#Stale-Read" class="headerlink" title="Stale Read"></a>Stale Read</h2><p>为了加速查询，CRDB 对读取时所使用的副本做了三个优化：</p>
<ul>
<li>Follower Read</li>
<li>Non-voting replicas Read</li>
<li>Stale Read</li>
</ul>
<p>这些都是一些比较常见的优化，主要工作是确认 Raft log 的 committed index 是否复合读的要求，说起来比较复杂，这里不展开说了（懒）</p>
<h2 id="Global-Transaction"><a href="#Global-Transaction" class="headerlink" title="Global Transaction"></a>Global Transaction</h2><p>这篇论文中说它提出了 a novel global transaction protocol，指的就是这个 global transaction，所以重点来讲讲这部分。这个 global transaction protocol 是为上面提到的 global table 准备的，回顾一下 global table 的要求：</p>
<ul>
<li>所有 region 都能够 local read</li>
<li>写入性能会受到影响</li>
</ul>
<p>CRDB 采用的方案叫 “write into the future”，写入一条未来 timestamp 的数据，并且 commit 线程要等待<strong>本地的</strong> HLC 时钟超过这个 future timestamp 才返回成功，在次之前都是 uncertainty window，但它只延迟返回事务成功，2PC 的 lock 会在第一时间被清理不会被推迟。</p>
<p>我们知道在使用 HLC 时，当读事务遇到 uncertainty window 时，需要重启事务用更新的 timestamp 来消除 uncertainty window 带来的破坏 linearizability 的风险（uncertainty refresh），图 step3 就需要做 uncertainty refresh。上面提到了，future write 返回成功的条件是 <code>local HLC &gt; future timestamp</code>，所以可能存在有的节点的 HLC 仍然小于 future timestamp 的情况，那么仅仅靠 uncertainty refresh 机制，就可能产生“提前读到”的问题。假如 w 是一个 future write 事务，r 读到了 w 的写入，随后的 r’ 没有读到 w 的写入。在真实时间上，发生的顺序是 r → r’，但是从读取的结果来看则是 r’ → w → r，这就违背了 linearizability。这里会让人困惑，都有 uncertainty refresh 机制的保证了，为什么还会提前读到呢？因为 uncertain window 是 HLC 的物理时间偏差的上限，但是 future timestamp 并不是取自 HLC 时间的，假设下面这种情况（uncertain window 取 250ms）：</p>
<ul>
<li>HLC(w) = 1000ms</li>
<li>HLC(r) = 1100ms</li>
<li>HLIC(r’) = 900ms</li>
<li>future timestamp = 1200ms</li>
</ul>
<p>当 HLC(r) 进行读取时，它的 uncertain window 是 <code>[1100ms, 1350ms]</code>，当遇到 future timestamp 时，它会重启并且将 uncertain window 更新为 <code>[1201ms, 1350ms]</code>，再次读取时即可读到这条 future write。但是，future timestamp 落在了 HLC(r’) 的 uncertain window 之外，因此 r’ 没有机会发现在自己的uncertainty window 里有一条数据，也没有机会做 uncertainty refresh。这里的关键点在于根据 future timestamp 来推 ts 是不安全的。</p>
<p><img src="global-txn-wait.png" alt="global-txn-wait"></p>
<p>解决这个问题也很简单，当读事务发现在自身 uncertain window 之外的 future timestamp 时（图中 step3，如上述 r’），可以忽略这条 future write；但是当读事务发现在自身的 uncertain window 之内的 future timestamp 时（图中 step4，如上述 r），则需要等待本地的 HLC 超过 future timestmap 时在进行读取，此时即可保证 r’ 的 HLC 的 uncertain window 至少能够发现这条 future write，防止 linearizability 被破坏。</p>
<h3 id="Local-Read"><a href="#Local-Read" class="headerlink" title="Local Read"></a>Local Read</h3><p>Global transaction 的一个要求是所有的 region 都能够进行 local read，那么这里就需要考虑副本读的兼容性，由于 Raft 的顺序性约束，副本读只需要保证 closed timestamp 被正常推进，就能够不漏读。因此关键点不在于给 future write 设置多长的 commit wait（当出现系统抖动时，wait 总有低于网络延迟的时候），而在于副本读需要从 write quorum 处获取到最新的 closed timestamp。</p>
<h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>这篇论文从工程学术两方面手把手的教人做 global database，看完之后感叹他们的格局真是大啊。俗话说“一流企业做标准”，如果盯着 MySQL 源码去魔改，大概这辈子也走不到这一步吧。</p>

    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E4%B8%8E-SQL"><span class="toc-text">抽象与 SQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Placement"><span class="toc-text">Placement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%99%91-locality-%E7%9A%84%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">考虑 locality 的优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Constraint"><span class="toc-text">Unique Constraint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Locality-Optimized-Search-LOS"><span class="toc-text">Locality Optimized Search (LOS)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stale-Read"><span class="toc-text">Stale Read</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Global-Transaction"><span class="toc-text">Global Transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Local-Read"><span class="toc-text">Local Read</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%AF%84%E4%BB%B7"><span class="toc-text">个人评价</span></a></li></ol>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
            <a class="prev" href="/2023/04/16/photography-2023-04-1/">
                <i class="iconfont icon-left"></i>
                <span class="prev-text">风景摄影-2023-04</span>
            </a>
        
        
            <a class="next" href="/2022/07/03/build-a-epyc-server/">
                
                <span class="prev-text">Epyc 服务器之坑</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>


            </main>
            <div class="copyright">
  
  <div>
      <img src="/assets/by-nc.svg">
  </div="text">
  

  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2020
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

    
        <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
        <script>
            if (window.mermaid) {
                mermaid.initialize({theme: 'forest'});
            }
        </script>
    
</html>
